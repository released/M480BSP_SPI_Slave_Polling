; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_SPI_SLAVE --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;29       */
;;;30     void CLK_DisableCKO(void)
000000  4801              LDR      r0,|L1.8|
;;;31     {
;;;32         /* Disable CKO clock source */
;;;33         CLK_DisableModuleClock(CLKO_MODULE);
000002  f7ffbffe          B.W      CLK_DisableModuleClock
;;;34     }
;;;35     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x57c00006

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;767      */
;;;768    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;769    {
;;;770        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;771    
;;;772        u32tmpVal = ~(1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;773        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L2.24|
;;;774        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;775    
;;;776        *(uint32_t *)u32tmpAddr &= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  438a              BICS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;777    }
000016  4770              BX       lr
;;;778    
                          ENDP

                  |L2.24|
                          DCD      0x40000204

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=1

                  CLK_DisablePLL PROC
;;;942      */
;;;943    void CLK_DisablePLL(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;944    {
;;;945        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000004  f8d01240          LDR      r1,[r0,#0x240]
000008  f4413180          ORR      r1,r1,#0x10000
00000c  f8c01240          STR      r1,[r0,#0x240]
;;;946    }
000010  4770              BX       lr
;;;947    
                          ENDP


                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_DisableSysTick PROC
;;;1021     */
;;;1022   void CLK_DisableSysTick(void)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;1023   {
;;;1024       /* Set System Tick counter disabled */
;;;1025       SysTick->CTRL = 0UL;
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
;;;1026   }
000008  4770              BX       lr
;;;1027   
                          ENDP


                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_DisableXtalRC PROC
;;;607      */
;;;608    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;609    {
;;;610        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4382              BICS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;611    }
00000e  4770              BX       lr
;;;612    
                          ENDP


                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;52       */
;;;53     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  4603              MOV      r3,r0
;;;54     {
;;;55         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;56         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | (u32ClkDiv) | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  ea411042          ORR      r0,r1,r2,LSL #5
000006  b510              PUSH     {r4,lr}               ;54
000008  f04f4280          MOV      r2,#0x40000000
00000c  f0400110          ORR      r1,r0,#0x10
000010  f8c21260          STR      r1,[r2,#0x260]
;;;57     
;;;58         /* Enable CKO clock source */
;;;59         CLK_EnableModuleClock(CLKO_MODULE);
000014  4c05              LDR      r4,|L6.44|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       CLK_EnableModuleClock
;;;60     
;;;61         /* Select CKO clock source */
;;;62         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0UL);
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2200              MOVS     r2,#0
000024  4619              MOV      r1,r3
000026  f7ffbffe          B.W      CLK_SetModuleClock
;;;63     }
;;;64     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x57c00006

                          AREA ||i.CLK_EnableDPDWKPin||, CODE, READONLY, ALIGN=1

                  CLK_EnableDPDWKPin PROC
;;;1098   
;;;1099   void CLK_EnableDPDWKPin(uint32_t u32TriggerType)
000000  f04f4180          MOV      r1,#0x40000000
;;;1100   {
;;;1101       uint32_t u32Pin1, u32Pin2, u32Pin3, u32Pin4;
;;;1102   
;;;1103       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000004  f8d121f4          LDR      r2,[r1,#0x1f4]
000008  b2d2              UXTB     r2,r2
;;;1104       {
;;;1105           u32Pin1 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN1_Pos);
;;;1106           u32Pin2 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN2_Pos);
;;;1107           u32Pin3 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN3_Pos);
;;;1108           u32Pin4 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN4_Pos);
;;;1109   
;;;1110           if(u32Pin1)
;;;1111           {
;;;1112               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN1_Msk)) | u32TriggerType;
;;;1113           }
;;;1114           else if(u32Pin2)
;;;1115           {
;;;1116               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN2_Msk)) | u32TriggerType;
;;;1117           }
;;;1118           else if(u32Pin3)
;;;1119           {
;;;1120               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN3_Msk)) | u32TriggerType;
;;;1121           }
;;;1122           else if(u32Pin4)
;;;1123           {
;;;1124               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN4_Msk)) | u32TriggerType;
;;;1125           }
;;;1126           else
;;;1127           {
;;;1128               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
;;;1129           }
;;;1130       }
;;;1131       else
;;;1132       {
;;;1133           CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
00000a  f8d12290          LDR      r2,[r1,#0x290]
00000e  f4223240          BIC      r2,r2,#0x30000
000012  4302              ORRS     r2,r2,r0
000014  f8c12290          STR      r2,[r1,#0x290]
;;;1134       }
;;;1135   }
000018  4770              BX       lr
;;;1136   
                          ENDP


                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;684      */
;;;685    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;686    {
;;;687        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;688    
;;;689        u32tmpVal = (1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;690        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L8.24|
;;;691        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;692    
;;;693        *(volatile uint32_t *)u32tmpAddr |= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  430a              ORRS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;694    }
000016  4770              BX       lr
;;;695    
                          ENDP

                  |L8.24|
                          DCD      0x40000204

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;789      */
;;;790    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;791    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;792        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32PllClk;
;;;793        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR, u32MinNO, u32basFreq;
;;;794    
;;;795        /* Disable PLL first to avoid unstable when setting PLL */
;;;796        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;797    
;;;798        /* PLL source clock is from HXT */
;;;799        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;800        {
;;;801            /* Enable HXT clock */
;;;802            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;803    
;;;804            /* Wait for HXT clock ready */
;;;805            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;806    
;;;807            /* Select PLL source clock from HXT */
;;;808            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;809            u32PllSrcClk = __HXT;
;;;810    
;;;811            /* u32NR start from 2 */
;;;812            u32NR = 2UL;
;;;813        }
;;;814    
;;;815        /* PLL source clock is from HIRC */
;;;816        else
;;;817        {
;;;818            /* Enable HIRC clock */
;;;819            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  f04f4080          MOV      r0,#0x40000000
000010  4e48              LDR      r6,|L9.308|
000012  f8d01200          LDR      r1,[r0,#0x200]
000016  b1c4              CBZ      r4,|L9.74|
000018  f0410104          ORR      r1,r1,#4
00001c  f8c01200          STR      r1,[r0,#0x200]
;;;820    
;;;821            /* Wait for HIRC clock ready */
;;;822            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       CLK_WaitClockReady
;;;823    
;;;824            /* Select PLL source clock from HIRC */
;;;825            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000026  f44f2000          MOV      r0,#0x80000
                  |L9.42|
;;;826            u32PllSrcClk = __HIRC;
;;;827    
;;;828            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;829            u32NR = 4UL;
;;;830        }
;;;831    
;;;832        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq >= FREQ_50MHZ))
00002a  9000              STR      r0,[sp,#0]
00002c  4842              LDR      r0,|L9.312|
00002e  4943              LDR      r1,|L9.316|
000030  4428              ADD      r0,r0,r5
000032  46b3              MOV      r11,r6                ;826
000034  4288              CMP      r0,r1
000036  d86d              BHI      |L9.276|
;;;833        {
;;;834    
;;;835            /* Find best solution */
;;;836            u32Min = (uint32_t) - 1;
;;;837            u32MinNR = 0UL;
000038  f04f0900          MOV      r9,#0
00003c  f04f32ff          MOV      r2,#0xffffffff        ;836
;;;838            u32MinNF = 0UL;
000040  464f              MOV      r7,r9
;;;839            u32MinNO = 0UL;
000042  464e              MOV      r6,r9
;;;840            u32basFreq = u32PllFreq;
000044  46ae              MOV      lr,r5
;;;841    
;;;842            for(u32NO = 1UL; u32NO <= 4UL; u32NO++)
000046  2001              MOVS     r0,#1
000048  e015              B        |L9.118|
                  |L9.74|
00004a  f0410101          ORR      r1,r1,#1              ;802
00004e  f8c01200          STR      r1,[r0,#0x200]        ;802
000052  2001              MOVS     r0,#1                 ;805
000054  f7fffffe          BL       CLK_WaitClockReady
000058  2000              MOVS     r0,#0                 ;808
00005a  e7e6              B        |L9.42|
                  |L9.92|
;;;843            {
;;;844                /* Break when get good results */
;;;845                if (u32Min == 0UL)
00005c  b3f2              CBZ      r2,|L9.220|
;;;846                {
;;;847                    break;
;;;848                }
;;;849    
;;;850                if (u32NO != 3UL)
00005e  2803              CMP      r0,#3
000060  d039              BEQ      |L9.214|
;;;851                {
;;;852    
;;;853                    if(u32NO == 4UL)
000062  2804              CMP      r0,#4
000064  d002              BEQ      |L9.108|
;;;854                    {
;;;855                        u32PllFreq = u32basFreq << 2;
;;;856                    }
;;;857                    else if(u32NO == 2UL)
000066  2802              CMP      r0,#2
000068  d105              BNE      |L9.118|
00006a  e002              B        |L9.114|
                  |L9.108|
00006c  ea4f058e          LSL      r5,lr,#2              ;855
000070  e001              B        |L9.118|
                  |L9.114|
;;;858                    {
;;;859                        u32PllFreq = u32basFreq << 1;
000072  ea4f054e          LSL      r5,lr,#1
                  |L9.118|
;;;860                    }
;;;861                    else
;;;862                    {
;;;863                    }
;;;864    
;;;865                    for(u32NR = 2UL; u32NR <= 32UL; u32NR++)
000076  2302              MOVS     r3,#2
                  |L9.120|
;;;866                    {
;;;867                        /* Break when get good results */
;;;868                        if (u32Min == 0UL)
000078  b36a              CBZ      r2,|L9.214|
;;;869                        {
;;;870                            break;
;;;871                        }
;;;872    
;;;873                        u32Tmp = u32PllSrcClk / u32NR;
00007a  fbbbf1f3          UDIV     r1,r11,r3
;;;874                        if((u32Tmp >= 4000000UL) && (u32Tmp <= 8000000UL))
00007e  4c30              LDR      r4,|L9.320|
000080  f8dfc0bc          LDR      r12,|L9.320|
000084  440c              ADD      r4,r4,r1
000086  f1cc0c00          RSB      r12,r12,#0
00008a  4564              CMP      r4,r12
00008c  d820              BHI      |L9.208|
;;;875                        {
;;;876                            for(u32NF = 2UL; u32NF <= 513UL; u32NF++)
00008e  2402              MOVS     r4,#2
;;;877                            {
;;;878                                /* u32Tmp2 is shifted 2 bits to avoid overflow */
;;;879                                u32Tmp2 = (((u32Tmp * 2UL) >> 2) * u32NF);
000090  f3c10a5d          UBFX     r10,r1,#1,#30
                  |L9.148|
;;;880    
;;;881                                if((u32Tmp2 >= FREQ_50MHZ) && (u32Tmp2 <= FREQ_125MHZ))
000094  f8dfc0a0          LDR      r12,|L9.312|
000098  fb0af104          MUL      r1,r10,r4             ;879
00009c  eb01080c          ADD      r8,r1,r12
0000a0  f8dfc0a0          LDR      r12,|L9.324|
0000a4  45e0              CMP      r8,r12
0000a6  d80e              BHI      |L9.198|
;;;882                                {
;;;883                                    u32Tmp3 = (u32Tmp2 > (u32PllFreq>>2)) ? u32Tmp2 - (u32PllFreq>>2) : (u32PllFreq>>2) - u32Tmp2;
0000a8  ebb10f95          CMP      r1,r5,LSR #2
0000ac  d902              BLS      |L9.180|
0000ae  eba10195          SUB      r1,r1,r5,LSR #2
0000b2  e001              B        |L9.184|
                  |L9.180|
0000b4  ebc10195          RSB      r1,r1,r5,LSR #2
                  |L9.184|
;;;884                                    if(u32Tmp3 < u32Min)
0000b8  4291              CMP      r1,r2
0000ba  d204              BCS      |L9.198|
;;;885                                    {
;;;886                                        u32Min = u32Tmp3;
0000bc  000a              MOVS     r2,r1
;;;887                                        u32MinNR = u32NR;
0000be  4699              MOV      r9,r3
;;;888                                        u32MinNF = u32NF;
0000c0  4627              MOV      r7,r4
;;;889                                        u32MinNO = u32NO;
0000c2  4606              MOV      r6,r0
;;;890    
;;;891                                        /* Break when get good results */
;;;892                                        if(u32Min == 0UL)
0000c4  d004              BEQ      |L9.208|
                  |L9.198|
0000c6  f2402101          MOV      r1,#0x201             ;876
0000ca  1c64              ADDS     r4,r4,#1              ;876
0000cc  428c              CMP      r4,r1                 ;876
0000ce  d9e1              BLS      |L9.148|
                  |L9.208|
0000d0  1c5b              ADDS     r3,r3,#1              ;876
0000d2  2b20              CMP      r3,#0x20              ;865
0000d4  d9d0              BLS      |L9.120|
                  |L9.214|
0000d6  1c40              ADDS     r0,r0,#1              ;865
0000d8  2804              CMP      r0,#4                 ;842
0000da  e000              B        |L9.222|
                  |L9.220|
0000dc  e000              B        |L9.224|
                  |L9.222|
0000de  d9bd              BLS      |L9.92|
                  |L9.224|
;;;893                                        {
;;;894                                            break;
;;;895                                        }
;;;896                                    }
;;;897                                }
;;;898                            }
;;;899                        }
;;;900                    }
;;;901                }
;;;902            }
;;;903    
;;;904            /* Enable and apply new PLL setting. */
;;;905            CLK->PLLCTL = u32CLK_SRC | ((u32MinNO - 1UL) << 14) | ((u32MinNR - 1UL) << 9) | (u32MinNF - 2UL);
0000e0  4819              LDR      r0,|L9.328|
0000e2  9900              LDR      r1,[sp,#0]
0000e4  eb003086          ADD      r0,r0,r6,LSL #14
0000e8  4a18              LDR      r2,|L9.332|
0000ea  4308              ORRS     r0,r0,r1
0000ec  eb022149          ADD      r1,r2,r9,LSL #9
0000f0  4308              ORRS     r0,r0,r1
0000f2  1eb9              SUBS     r1,r7,#2
0000f4  4308              ORRS     r0,r0,r1
0000f6  f04f4180          MOV      r1,#0x40000000
0000fa  f8c10240          STR      r0,[r1,#0x240]
;;;906    
;;;907            /* Wait for PLL clock stable */
;;;908            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000fe  2004              MOVS     r0,#4
000100  f7fffffe          BL       CLK_WaitClockReady
;;;909    
;;;910            /* Actual PLL output clock frequency */
;;;911            u32PllClk = u32PllSrcClk / (u32MinNO * (u32MinNR)) * (u32MinNF) * 2UL;
000104  fb06f609          MUL      r6,r6,r9
000108  fbbbf0f6          UDIV     r0,r11,r6
00010c  4378              MULS     r0,r7,r0
00010e  0040              LSLS     r0,r0,#1
;;;912        }
;;;913        else
;;;914        {
;;;915            /* Wrong frequency request. Just return default setting. */
;;;916            /* Apply default PLL setting and return */
;;;917            if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;918            {
;;;919                CLK->PLLCTL = CLK_PLLCTL_192MHz_HXT;
;;;920            }
;;;921            else
;;;922            {
;;;923                CLK->PLLCTL = CLK_PLLCTL_192MHz_HIRC;
;;;924            }
;;;925    
;;;926            /* Wait for PLL clock stable */
;;;927            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;928    
;;;929            /* Actual PLL output clock frequency */
;;;930            u32PllClk = CLK_GetPLLClockFreq();
;;;931        }
;;;932    
;;;933        return u32PllClk;
;;;934    }
000110  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.276|
000114  b15c              CBZ      r4,|L9.302|
000116  490e              LDR      r1,|L9.336|
                  |L9.280|
000118  f04f4080          MOV      r0,#0x40000000        ;923
00011c  f8c01240          STR      r1,[r0,#0x240]        ;923
000120  2004              MOVS     r0,#4                 ;927
000122  f7fffffe          BL       CLK_WaitClockReady
000126  e8bd4ff8          POP      {r3-r11,lr}           ;930
00012a  f7ffbffe          B.W      CLK_GetPLLClockFreq
                  |L9.302|
00012e  f244211e          MOV      r1,#0x421e            ;919
000132  e7f1              B        |L9.280|
;;;935    
                          ENDP

                  |L9.308|
                          DCD      0x00b71b00
                  |L9.312|
                          DCD      0xfd050f80
                  |L9.316|
                          DCD      0x1ad27480
                  |L9.320|
                          DCD      0xffc2f700
                  |L9.324|
                          DCD      0x047868c0
                  |L9.328|
                          DCD      0xffffc000
                  |L9.332|
                          DCD      0xfffffe00
                  |L9.336|
                          DCD      0x0008421e

                          AREA ||i.CLK_EnableSPDWKPin||, CODE, READONLY, ALIGN=2

                  CLK_EnableSPDWKPin PROC
;;;1166    */
;;;1167   void CLK_EnableSPDWKPin(uint32_t u32Port, uint32_t u32Pin, uint32_t u32TriggerType, uint32_t u32DebounceEn)
000000  b530              PUSH     {r4,r5,lr}
;;;1168   {
;;;1169       uint32_t u32tmpAddr = 0UL;
;;;1170       uint32_t u32tmpVal = 0UL;
;;;1171   
;;;1172       /* GPx Stand-by Power-down Wake-up Pin Select */
;;;1173       u32tmpAddr = (uint32_t)&CLK->PASWKCTL;
000002  4c07              LDR      r4,|L10.32|
;;;1174       u32tmpAddr += (0x4UL * u32Port);
000004  eb040080          ADD      r0,r4,r0,LSL #2
;;;1175   
;;;1176       u32tmpVal = inpw((uint32_t *)u32tmpAddr);
000008  6804              LDR      r4,[r0,#0]
;;;1177       u32tmpVal = (u32tmpVal & ~(CLK_PASWKCTL_WKPSEL_Msk | CLK_PASWKCTL_PRWKEN_Msk | CLK_PASWKCTL_PFWKEN_Msk | CLK_PASWKCTL_DBEN_Msk | CLK_PASWKCTL_WKEN_Msk)) |
00000a  f24015f7          MOV      r5,#0x1f7
00000e  43ac              BICS     r4,r4,r5
000010  ea441101          ORR      r1,r4,r1,LSL #4
000014  4311              ORRS     r1,r1,r2
000016  4319              ORRS     r1,r1,r3
000018  f0410101          ORR      r1,r1,#1
;;;1178                   (u32Pin << CLK_PASWKCTL_WKPSEL_Pos) | u32TriggerType | u32DebounceEn | CLK_SPDWKPIN_ENABLE;
;;;1179       outpw((uint32_t *)u32tmpAddr, u32tmpVal);
00001c  6001              STR      r1,[r0,#0]
;;;1180   }
00001e  bd30              POP      {r4,r5,pc}
;;;1181   
                          ENDP

                  |L10.32|
                          DCD      0x400002a0

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_EnableSysTick PROC
;;;990      */
;;;991    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b530              PUSH     {r4,r5,lr}
;;;992    {
;;;993        /* Set System Tick counter disabled */
;;;994        SysTick->CTRL = 0UL;
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2500              MOVS     r5,#0
000008  6115              STR      r5,[r2,#0x10]
;;;995    
;;;996        /* Set System Tick clock source */
;;;997        if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )
00000a  2804              CMP      r0,#4
00000c  d00f              BEQ      |L11.46|
;;;998        {
;;;999            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;1000       }
;;;1001       else
;;;1002       {
;;;1003           CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000e  f04f4380          MOV      r3,#0x40000000
000012  f8d34210          LDR      r4,[r3,#0x210]
000016  f0240438          BIC      r4,r4,#0x38
00001a  4304              ORRS     r4,r4,r0
00001c  f8c34210          STR      r4,[r3,#0x210]
                  |L11.32|
;;;1004       }
;;;1005   
;;;1006       /* Set System Tick reload value */
;;;1007       SysTick->LOAD = u32Count;
000020  6151              STR      r1,[r2,#0x14]
;;;1008   
;;;1009       /* Clear System Tick current value and counter flag */
;;;1010       SysTick->VAL = 0UL;
000022  6195              STR      r5,[r2,#0x18]
;;;1011   
;;;1012       /* Set System Tick interrupt enabled and counter enabled */
;;;1013       SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
;;;1014   }
00002c  bd30              POP      {r4,r5,pc}
                  |L11.46|
00002e  6910              LDR      r0,[r2,#0x10]         ;999
000030  f0400004          ORR      r0,r0,#4              ;999
000034  6110              STR      r0,[r2,#0x10]         ;999
000036  e7f3              B        |L11.32|
;;;1015   
                          ENDP


                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_EnableXtalRC PROC
;;;591      */
;;;592    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;593    {
;;;594        CLK->PWRCTL |= u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4302              ORRS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;595    }
00000e  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;256      */
;;;257    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;260        return SystemCoreClock;
000006  4801              LDR      r0,|L13.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;261    }
00000a  bd10              POP      {r4,pc}
;;;262    
                          ENDP

                  |L13.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;243      */
;;;244    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;245    {
;;;246        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;247        return SystemCoreClock;
000006  4801              LDR      r0,|L14.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;248    }
00000a  bd10              POP      {r4,pc}
;;;249    
                          ENDP

                  |L14.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;119      */
;;;120    uint32_t CLK_GetHXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;121    {
;;;122        uint32_t u32Freq;
;;;123    
;;;124        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  07c0              LSLS     r0,r0,#31
00000a  d000              BEQ      |L15.14|
;;;125        {
;;;126            u32Freq = __HXT;
00000c  4800              LDR      r0,|L15.16|
                  |L15.14|
;;;127        }
;;;128        else
;;;129        {
;;;130            u32Freq = 0UL;
;;;131        }
;;;132    
;;;133        return u32Freq;
;;;134    }
00000e  4770              BX       lr
;;;135    
                          ENDP

                  |L15.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=1

                  CLK_GetLXTFreq PROC
;;;142      */
;;;143    uint32_t CLK_GetLXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;144    {
;;;145        uint32_t u32Freq;
;;;146        if((CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk) == CLK_PWRCTL_LXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  0780              LSLS     r0,r0,#30
00000a  d502              BPL      |L16.18|
;;;147        {
;;;148            u32Freq = __LXT;
00000c  f44f4000          MOV      r0,#0x8000
;;;149        }
;;;150        else
;;;151        {
;;;152            u32Freq = 0UL;
;;;153        }
;;;154    
;;;155        return u32Freq;
;;;156    }
000010  4770              BX       lr
                  |L16.18|
000012  2000              MOVS     r0,#0                 ;152
000014  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.CLK_GetModuleClockDivider||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockDivider PROC
;;;1322     */
;;;1323   uint32_t CLK_GetModuleClockDivider(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1324   {
;;;1325       uint32_t u32div = 0;
;;;1326       uint32_t u32DivTbl[4] = {0x0, 0x4, 0xc, 0x10};
000002  4914              LDR      r1,|L17.84|
;;;1327   
;;;1328       if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000004  f4103f7f          TST      r0,#0x3fc00
000008  c91e              LDM      r1,{r1-r4}            ;1326
00000a  e88d001e          STM      sp,{r1-r4}            ;1326
00000e  d01f              BEQ      |L17.80|
;;;1329       {
;;;1330           /* Get clock divider control register address */
;;;1331           u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000010  f3c04281          UBFX     r2,r0,#18,#2
000014  f85d1022          LDR      r1,[sp,r2,LSL #2]
000018  4a0f              LDR      r2,|L17.88|
00001a  4411              ADD      r1,r1,r2
;;;1332           if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
00001c  0652              LSLS     r2,r2,#25
00001e  f8d221f4          LDR      r2,[r2,#0x1f4]
000022  b2d2              UXTB     r2,r2
000024  2a01              CMP      r2,#1
000026  d108              BNE      |L17.58|
;;;1333           {
;;;1334               if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
000028  43c2              MVNS     r2,r0
;;;1335                   u32div = (uint32_t)&CLK->CLKDIV2;
00002a  4b0c              LDR      r3,|L17.92|
00002c  06d2              LSLS     r2,r2,#27             ;1334
00002e  d003              BEQ      |L17.56|
;;;1336               else if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
000030  f000021f          AND      r2,r0,#0x1f
000034  2a1d              CMP      r2,#0x1d
000036  d100              BNE      |L17.58|
                  |L17.56|
;;;1337                   u32div = (uint32_t)&CLK->CLKDIV2;
000038  4619              MOV      r1,r3
                  |L17.58|
;;;1338           }
;;;1339           /* Get clock divider number setting */
;;;1340           return ((M32(u32div) & (MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx))) >> MODULE_CLKDIV_Pos(u32ModuleIdx));
00003a  6809              LDR      r1,[r1,#0]
00003c  f3c02287          UBFX     r2,r0,#10,#8
000040  f3c01044          UBFX     r0,r0,#5,#5
000044  4082              LSLS     r2,r2,r0
000046  4011              ANDS     r1,r1,r2
000048  fa21f000          LSR      r0,r1,r0
                  |L17.76|
;;;1341       }
;;;1342       else
;;;1343           return 0;
;;;1344   }
00004c  b004              ADD      sp,sp,#0x10
00004e  bd10              POP      {r4,pc}
                  |L17.80|
000050  2000              MOVS     r0,#0                 ;1343
000052  e7fb              B        |L17.76|
;;;1345   
                          ENDP

                  |L17.84|
                          DCD      ||.constdata||+0x10
                  |L17.88|
                          DCD      0x40000220
                  |L17.92|
                          DCD      0x40000228

                          AREA ||i.CLK_GetModuleClockSource||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockSource PROC
;;;1273     */
;;;1274   uint32_t CLK_GetModuleClockSource(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1275   {
;;;1276       uint32_t u32sel = 0;
;;;1277       uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};
000002  491d              LDR      r1,|L18.120|
000004  c91e              LDM      r1,{r1-r4}
000006  e88d001e          STM      sp,{r1-r4}
;;;1278   
;;;1279       /* Get clock source selection setting */
;;;1280       if(u32ModuleIdx == EPWM0_MODULE)
00000a  4a1c              LDR      r2,|L18.124|
;;;1281           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk) >> CLK_CLKSEL2_EPWM0SEL_Pos);
00000c  0691              LSLS     r1,r2,#26
00000e  4290              CMP      r0,r2                 ;1280
000010  d105              BNE      |L18.30|
000012  f8d10218          LDR      r0,[r1,#0x218]
000016  f0000001          AND      r0,r0,#1
                  |L18.26|
;;;1282       else if(u32ModuleIdx == EPWM1_MODULE)
;;;1283           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk) >> CLK_CLKSEL2_EPWM1SEL_Pos);
;;;1284       else if(u32ModuleIdx == BPWM0_MODULE)
;;;1285           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk) >> CLK_CLKSEL2_BPWM0SEL_Pos);
;;;1286       else if(u32ModuleIdx == BPWM1_MODULE)
;;;1287           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk) >> CLK_CLKSEL2_BPWM1SEL_Pos);
;;;1288       else if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
;;;1289       {
;;;1290           /* Get clock select control register address */
;;;1291           u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
;;;1292           /* Get clock source selection setting */
;;;1293           return ((M32(u32sel) & (MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx))) >> MODULE_CLKSEL_Pos(u32ModuleIdx));
;;;1294       }
;;;1295       else
;;;1296           return 0;
;;;1297   }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  4a18              LDR      r2,|L18.128|
000020  4290              CMP      r0,r2                 ;1282
000022  d104              BNE      |L18.46|
000024  f8d10218          LDR      r0,[r1,#0x218]        ;1283
000028  f3c00040          UBFX     r0,r0,#1,#1           ;1283
00002c  e7f5              B        |L18.26|
                  |L18.46|
00002e  4a15              LDR      r2,|L18.132|
000030  4290              CMP      r0,r2                 ;1284
000032  d104              BNE      |L18.62|
000034  f8d10218          LDR      r0,[r1,#0x218]        ;1285
000038  f3c02000          UBFX     r0,r0,#8,#1           ;1285
00003c  e7ed              B        |L18.26|
                  |L18.62|
00003e  4a12              LDR      r2,|L18.136|
000040  4290              CMP      r0,r2                 ;1286
000042  d104              BNE      |L18.78|
000044  f8d10218          LDR      r0,[r1,#0x218]        ;1287
000048  f3c02040          UBFX     r0,r0,#9,#1           ;1287
00004c  e7e5              B        |L18.26|
                  |L18.78|
00004e  0e41              LSRS     r1,r0,#25             ;1288
000050  0749              LSLS     r1,r1,#29             ;1288
000052  d00e              BEQ      |L18.114|
000054  f3c07201          UBFX     r2,r0,#28,#2          ;1291
000058  f85d1022          LDR      r1,[sp,r2,LSL #2]     ;1291
00005c  4a0b              LDR      r2,|L18.140|
00005e  5889              LDR      r1,[r1,r2]            ;1293
000060  f3c06242          UBFX     r2,r0,#25,#3          ;1293
000064  f3c05004          UBFX     r0,r0,#20,#5          ;1293
000068  4082              LSLS     r2,r2,r0              ;1293
00006a  4011              ANDS     r1,r1,r2              ;1293
00006c  fa21f000          LSR      r0,r1,r0              ;1293
000070  e7d3              B        |L18.26|
                  |L18.114|
000072  2000              MOVS     r0,#0                 ;1296
000074  e7d1              B        |L18.26|
;;;1298   
                          ENDP

000076  0000              DCW      0x0000
                  |L18.120|
                          DCD      ||.constdata||
                  |L18.124|
                          DCD      0xa2000010
                  |L18.128|
                          DCD      0xa2100011
                  |L18.132|
                          DCD      0xa2800012
                  |L18.136|
                          DCD      0xa2900013
                  |L18.140|
                          DCD      0x40000210

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;163      */
;;;164    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166        uint32_t u32Freq;
;;;167        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;168    
;;;169        if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  0742              LSLS     r2,r0,#29
;;;170        {
;;;171            u32Freq = SystemCoreClock;
000010  4813              LDR      r0,|L19.96|
000012  d017              BEQ      |L19.68|
;;;172        }
;;;173        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV2)
000014  f8d12234          LDR      r2,[r1,#0x234]
000018  f0020207          AND      r2,r2,#7
00001c  2a01              CMP      r2,#1
00001e  d013              BEQ      |L19.72|
;;;174        {
;;;175            u32Freq = SystemCoreClock / 2UL;
;;;176        }
;;;177        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV4)
000020  f8d12234          LDR      r2,[r1,#0x234]
000024  f0020207          AND      r2,r2,#7
000028  2a02              CMP      r2,#2
00002a  d010              BEQ      |L19.78|
;;;178        {
;;;179            u32Freq = SystemCoreClock / 4UL;
;;;180        }
;;;181        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV8)
00002c  f8d12234          LDR      r2,[r1,#0x234]
000030  f0020207          AND      r2,r2,#7
000034  2a03              CMP      r2,#3
000036  d00d              BEQ      |L19.84|
;;;182        {
;;;183            u32Freq = SystemCoreClock / 8UL;
;;;184        }
;;;185        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV16)
000038  f8d11234          LDR      r1,[r1,#0x234]
00003c  f0010107          AND      r1,r1,#7
000040  2904              CMP      r1,#4
000042  d00a              BEQ      |L19.90|
                  |L19.68|
000044  6800              LDR      r0,[r0,#0]            ;171  ; SystemCoreClock
;;;186        {
;;;187            u32Freq = SystemCoreClock / 16UL;
;;;188        }
;;;189        else
;;;190        {
;;;191            u32Freq = SystemCoreClock;
;;;192        }
;;;193    
;;;194        return u32Freq;
;;;195    }
000046  bd10              POP      {r4,pc}
                  |L19.72|
000048  6800              LDR      r0,[r0,#0]            ;175  ; SystemCoreClock
00004a  0840              LSRS     r0,r0,#1              ;175
00004c  bd10              POP      {r4,pc}
                  |L19.78|
00004e  6800              LDR      r0,[r0,#0]            ;179  ; SystemCoreClock
000050  0880              LSRS     r0,r0,#2              ;179
000052  bd10              POP      {r4,pc}
                  |L19.84|
000054  6800              LDR      r0,[r0,#0]            ;183  ; SystemCoreClock
000056  08c0              LSRS     r0,r0,#3              ;183
000058  bd10              POP      {r4,pc}
                  |L19.90|
00005a  6800              LDR      r0,[r0,#0]            ;187  ; SystemCoreClock
00005c  0900              LSRS     r0,r0,#4              ;187
00005e  bd10              POP      {r4,pc}
;;;196    
                          ENDP

                  |L19.96|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;203      */
;;;204    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206        uint32_t u32Freq;
;;;207        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;208    
;;;209        if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  f0100f70          TST      r0,#0x70
;;;210        {
;;;211            u32Freq = SystemCoreClock;
000012  4814              LDR      r0,|L20.100|
000014  d017              BEQ      |L20.70|
;;;212        }
;;;213        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV2)
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f3c21202          UBFX     r2,r2,#4,#3
00001e  2a01              CMP      r2,#1
000020  d013              BEQ      |L20.74|
;;;214        {
;;;215            u32Freq = SystemCoreClock / 2UL;
;;;216        }
;;;217        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV4)
000022  f8d12234          LDR      r2,[r1,#0x234]
000026  f3c21202          UBFX     r2,r2,#4,#3
00002a  2a02              CMP      r2,#2
00002c  d010              BEQ      |L20.80|
;;;218        {
;;;219            u32Freq = SystemCoreClock / 4UL;
;;;220        }
;;;221        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV8)
00002e  f8d12234          LDR      r2,[r1,#0x234]
000032  f3c21202          UBFX     r2,r2,#4,#3
000036  2a03              CMP      r2,#3
000038  d00d              BEQ      |L20.86|
;;;222        {
;;;223            u32Freq = SystemCoreClock / 8UL;
;;;224        }
;;;225        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV16)
00003a  f8d11234          LDR      r1,[r1,#0x234]
00003e  f3c11102          UBFX     r1,r1,#4,#3
000042  2904              CMP      r1,#4
000044  d00a              BEQ      |L20.92|
                  |L20.70|
000046  6800              LDR      r0,[r0,#0]            ;211  ; SystemCoreClock
;;;226        {
;;;227            u32Freq = SystemCoreClock / 16UL;
;;;228        }
;;;229        else
;;;230        {
;;;231            u32Freq = SystemCoreClock;
;;;232        }
;;;233    
;;;234        return u32Freq;
;;;235    }
000048  bd10              POP      {r4,pc}
                  |L20.74|
00004a  6800              LDR      r0,[r0,#0]            ;215  ; SystemCoreClock
00004c  0840              LSRS     r0,r0,#1              ;215
00004e  bd10              POP      {r4,pc}
                  |L20.80|
000050  6800              LDR      r0,[r0,#0]            ;219  ; SystemCoreClock
000052  0880              LSRS     r0,r0,#2              ;219
000054  bd10              POP      {r4,pc}
                  |L20.86|
000056  6800              LDR      r0,[r0,#0]            ;223  ; SystemCoreClock
000058  08c0              LSRS     r0,r0,#3              ;223
00005a  bd10              POP      {r4,pc}
                  |L20.92|
00005c  6800              LDR      r0,[r0,#0]            ;227  ; SystemCoreClock
00005e  0900              LSRS     r0,r0,#4              ;227
000060  bd10              POP      {r4,pc}
;;;236    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;1187     */
;;;1188   uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;1189   {
;;;1190       uint32_t u32PllFreq = 0UL, u32PllReg;
;;;1191       uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;1192       uint8_t au8NoTbl[4] = {1U, 2U, 2U, 4U};
000002  a110              ADR      r1,|L21.68|
000004  2000              MOVS     r0,#0                 ;1190
000006  6809              LDR      r1,[r1,#0]
;;;1193   
;;;1194       u32PllReg = CLK->PLLCTL;
000008  9100              STR      r1,[sp,#0]
00000a  f04f4180          MOV      r1,#0x40000000
00000e  f8d11240          LDR      r1,[r1,#0x240]
;;;1195   
;;;1196       if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000012  f4112fa0          TST      r1,#0x50000
000016  d113              BNE      |L21.64|
;;;1197       {
;;;1198           u32PllFreq = 0UL;           /* PLL is in power down mode or fix low */
;;;1199       }
;;;1200       else if((u32PllReg & CLK_PLLCTL_BP_Msk) == CLK_PLLCTL_BP_Msk)
;;;1201       {
;;;1202           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1203           {
;;;1204               u32FIN = __HIRC;    /* PLL source clock from HIRC */
000018  480b              LDR      r0,|L21.72|
00001a  038a              LSLS     r2,r1,#14             ;1200
00001c  d410              BMI      |L21.64|
;;;1205           }
;;;1206           else
;;;1207           {
;;;1208               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1209           }
;;;1210   
;;;1211           u32PllFreq = u32FIN;
;;;1212       }
;;;1213       else
;;;1214       {
;;;1215           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1216           {
;;;1217               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1218           }
;;;1219           else
;;;1220           {
;;;1221               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1222           }
;;;1223           /* PLL is output enabled in normal work mode */
;;;1224           u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;1225           u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2UL;
00001e  f3c10008          UBFX     r0,r1,#0,#9
000022  f3c13281          UBFX     r2,r1,#14,#2          ;1224
;;;1226           u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 1UL;
;;;1227   
;;;1228           /* u32FIN is shifted 2 bits to avoid overflow */
;;;1229           u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2) * 2UL;
000026  4b09              LDR      r3,|L21.76|
000028  1c80              ADDS     r0,r0,#2
00002a  f81d2002          LDRB     r2,[sp,r2]            ;1224
00002e  f3c12144          UBFX     r1,r1,#9,#5           ;1226
000032  4358              MULS     r0,r3,r0
000034  1c49              ADDS     r1,r1,#1
000036  fb11f102          SMULBB   r1,r1,r2
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  00c0              LSLS     r0,r0,#3
                  |L21.64|
;;;1230       }
;;;1231   
;;;1232       return u32PllFreq;
;;;1233   }
000040  bd08              POP      {r3,pc}
;;;1234   
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
000044  01020204          DCB      1,2,2,4
                  |L21.72|
                          DCD      0x00b71b00
                  |L21.76|
                          DCD      0x002dc6c0

                          AREA ||i.CLK_GetPMUWKSrc||, CODE, READONLY, ALIGN=1

                  CLK_GetPMUWKSrc PROC
;;;1145   
;;;1146   uint32_t CLK_GetPMUWKSrc(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;1147   {
;;;1148       return (CLK->PMUSTS);
000004  f8d00294          LDR      r0,[r0,#0x294]
;;;1149   }
000008  4770              BX       lr
;;;1150   
                          ENDP


                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;101      */
;;;102    void CLK_Idle(void)
000000  4806              LDR      r0,|L23.28|
;;;103    {
;;;104        /* Set the processor uses sleep as its low power mode */
;;;105        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;106    
;;;107        /* Set chip in idle mode because of WFI command */
;;;108        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;109    
;;;110        /* Chip enter idle mode after CPU run WFI instruction */
;;;111        __WFI();
000018  bf30              WFI      
;;;112    }
00001a  4770              BX       lr
;;;113    
                          ENDP

                  |L23.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;71       */
;;;72     void CLK_PowerDown(void)
000000  480a              LDR      r0,|L24.44|
;;;73     {
;;;74         uint32_t u32HIRCTRIMCTL;
;;;75     
;;;76         /* Set the processor uses deep sleep as its low power mode */
;;;77         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;78     
;;;79         /* Set system Power-down enabled */
;;;80         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0410180          ORR      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;81     
;;;82         /* Store HIRC control register */
;;;83         u32HIRCTRIMCTL = SYS->IRCTCTL;
000018  f8501ff0          LDR      r1,[r0,#0xf0]!
;;;84     
;;;85         /* Disable HIRC auto trim */
;;;86         SYS->IRCTCTL &= (~SYS_IRCTCTL_FREQSEL_Msk);
00001c  6802              LDR      r2,[r0,#0]
00001e  f0220203          BIC      r2,r2,#3
000022  6002              STR      r2,[r0,#0]
;;;87     
;;;88         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;89         __WFI();
000024  bf30              WFI      
;;;90     
;;;91         /* Restore HIRC control register */
;;;92         SYS->IRCTCTL = u32HIRCTRIMCTL;
000026  6001              STR      r1,[r0,#0]
;;;93     }
000028  4770              BX       lr
;;;94     
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      0xe000ed10

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;270      */
;;;271    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;272    {
;;;273        uint32_t u32HIRCSTB;
;;;274    
;;;275        /* Read HIRC clock source stable flag */
;;;276        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  f04f4480          MOV      r4,#0x40000000
000006  4606              MOV      r6,r0                 ;272
000008  f8d40250          LDR      r0,[r4,#0x250]
00000c  f0000510          AND      r5,r0,#0x10
;;;277    
;;;278        /* The range of u32Hclk is running up to 192 MHz */
;;;279        if(u32Hclk > FREQ_192MHZ)
000010  481b              LDR      r0,|L25.128|
000012  4286              CMP      r6,r0
000014  d900              BLS      |L25.24|
;;;280        {
;;;281            u32Hclk = FREQ_192MHZ;
000016  4606              MOV      r6,r0
                  |L25.24|
;;;282        }
;;;283    
;;;284        /* Switch HCLK clock source to HIRC clock for safe */
;;;285        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000018  f8d40200          LDR      r0,[r4,#0x200]
00001c  f0400004          ORR      r0,r0,#4
000020  f8c40200          STR      r0,[r4,#0x200]
;;;286        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000024  2010              MOVS     r0,#0x10
000026  f5047400          ADD      r4,r4,#0x200
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;287        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
00002e  6920              LDR      r0,[r4,#0x10]
000030  f0400007          ORR      r0,r0,#7
000034  6120              STR      r0,[r4,#0x10]
;;;288        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f020000f          BIC      r0,r0,#0xf
00003c  6220              STR      r0,[r4,#0x20]
;;;289    
;;;290        /* Configure PLL setting if HXT clock is enabled */
;;;291        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
00003e  6820              LDR      r0,[r4,#0]
000040  f5a47400          SUB      r4,r4,#0x200
000044  07c0              LSLS     r0,r0,#31
;;;292        {
;;;293            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, u32Hclk);
;;;294        }
;;;295        /* Configure PLL setting if HXT clock is not enabled */
;;;296        else
;;;297        {
;;;298            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, u32Hclk);
000046  4631              MOV      r1,r6
000048  d004              BEQ      |L25.84|
00004a  2000              MOVS     r0,#0                 ;293
00004c  f7fffffe          BL       CLK_EnablePLL
000050  4606              MOV      r6,r0                 ;293
000052  e008              B        |L25.102|
                  |L25.84|
000054  f44f2000          MOV      r0,#0x80000
000058  f7fffffe          BL       CLK_EnablePLL
00005c  4606              MOV      r6,r0
;;;299    
;;;300            /* Read HIRC clock source stable flag */
;;;301            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00005e  f8d40250          LDR      r0,[r4,#0x250]
000062  f0000510          AND      r5,r0,#0x10
                  |L25.102|
;;;302        }
;;;303    
;;;304        /* Select HCLK clock source to PLL,
;;;305           and update system core clock
;;;306        */
;;;307        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1UL));
000066  2100              MOVS     r1,#0
000068  2002              MOVS     r0,#2
00006a  f7fffffe          BL       CLK_SetHCLK
;;;308    
;;;309        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;310        if(u32HIRCSTB == 0UL)
00006e  b92d              CBNZ     r5,|L25.124|
;;;311        {
;;;312            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000070  f8d40200          LDR      r0,[r4,#0x200]
000074  f0200004          BIC      r0,r0,#4
000078  f8c40200          STR      r0,[r4,#0x200]
                  |L25.124|
;;;313        }
;;;314    
;;;315        /* Return actually HCLK frequency is PLL frequency divide 1 */
;;;316        return u32Hclk;
00007c  4630              MOV      r0,r6
;;;317    }
00007e  bd70              POP      {r4-r6,pc}
;;;318    
                          ENDP

                  |L25.128|
                          DCD      0x0b71b000

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=1

                  CLK_SetHCLK PROC
;;;332      */
;;;333    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;334    {
;;;335        uint32_t u32HIRCSTB;
;;;336    
;;;337        /* Read HIRC clock source stable flag */
;;;338        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  f04f4480          MOV      r4,#0x40000000
000008  4607              MOV      r7,r0                 ;334
00000a  f8d40250          LDR      r0,[r4,#0x250]
00000e  460e              MOV      r6,r1                 ;334
000010  f0000510          AND      r5,r0,#0x10
;;;339    
;;;340        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;341        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f0400004          ORR      r0,r0,#4
00001c  f8c40200          STR      r0,[r4,#0x200]
;;;342        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f5047400          ADD      r4,r4,#0x200
000026  f7fffffe          BL       CLK_WaitClockReady
;;;343        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f0400007          ORR      r0,r0,#7
000030  6120              STR      r0,[r4,#0x10]
;;;344    
;;;345        /* Apply new Divider */
;;;346        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000032  6a20              LDR      r0,[r4,#0x20]
000034  f020000f          BIC      r0,r0,#0xf
000038  4330              ORRS     r0,r0,r6
00003a  6220              STR      r0,[r4,#0x20]
;;;347    
;;;348        /* Switch HCLK to new HCLK source */
;;;349        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f0200007          BIC      r0,r0,#7
000042  4338              ORRS     r0,r0,r7
000044  6120              STR      r0,[r4,#0x10]
000046  f5a47400          SUB      r4,r4,#0x200
;;;350    
;;;351        /* Update System Core Clock */
;;;352        SystemCoreClockUpdate();
00004a  f7fffffe          BL       SystemCoreClockUpdate
;;;353    
;;;354        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;355        if(u32HIRCSTB == 0UL)
00004e  2d00              CMP      r5,#0
000050  d105              BNE      |L26.94|
;;;356        {
;;;357            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000052  f8d40200          LDR      r0,[r4,#0x200]
000056  f0200004          BIC      r0,r0,#4
00005a  f8c40200          STR      r0,[r4,#0x200]
                  |L26.94|
;;;358        }
;;;359    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;360    
                          ENDP


                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;502      */
;;;503    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;504    {
;;;505        uint32_t u32sel = 0U, u32div = 0U;
;;;506    
;;;507        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  f4103f7f          TST      r0,#0x3fc00
000006  d02e              BEQ      |L27.102|
;;;508        {
;;;509            /* Get clock divider control register address */
;;;510            if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000008  f04f4380          MOV      r3,#0x40000000
00000c  f8d331f4          LDR      r3,[r3,#0x1f4]
;;;511            {
;;;512                if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
;;;513                {
;;;514                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;515                }
;;;516                else if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
;;;517                {
;;;518                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;519                }
;;;520                else if (MODULE_CLKDIV(u32ModuleIdx) == 2U)
;;;521                {
;;;522                    u32div = (uint32_t)&CLK->CLKDIV3;
000010  f8dfc078          LDR      r12,|L27.140|
000014  b2df              UXTB     r7,r3                 ;510
;;;523                }
;;;524                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
;;;525                {
;;;526                    u32div = (uint32_t)&CLK->CLKDIV4;
;;;527                }
;;;528                else
;;;529                {
;;;530                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
000016  4b1d              LDR      r3,|L27.140|
000018  f3c04481          UBFX     r4,r0,#18,#2          ;512
00001c  3b0c              SUBS     r3,r3,#0xc
00001e  ea6f4590          MVN      r5,r0,LSR #18         ;524
000022  f10c0604          ADD      r6,r12,#4             ;526
000026  eb030384          ADD      r3,r3,r4,LSL #2
00002a  2f01              CMP      r7,#1                 ;510
00002c  d002              BEQ      |L27.52|
;;;531                }
;;;532            }
;;;533            else
;;;534            {
;;;535                /* Get clock divider control register address */
;;;536                if(MODULE_CLKDIV(u32ModuleIdx) == 2U)
00002e  2c02              CMP      r4,#2
000030  d00d              BEQ      |L27.78|
000032  e001              B        |L27.56|
                  |L27.52|
000034  2c02              CMP      r4,#2                 ;512
000036  d002              BEQ      |L27.62|
                  |L27.56|
;;;537                {
;;;538                    u32div = (uint32_t)&CLK->CLKDIV3;
;;;539                }
;;;540                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
000038  07ac              LSLS     r4,r5,#30
00003a  d00a              BEQ      |L27.82|
00003c  e00a              B        |L27.84|
                  |L27.62|
00003e  43c3              MVNS     r3,r0                 ;512
000040  06dc              LSLS     r4,r3,#27             ;512
000042  4b13              LDR      r3,|L27.144|
000044  d006              BEQ      |L27.84|
000046  f000041f          AND      r4,r0,#0x1f           ;516
00004a  2c1d              CMP      r4,#0x1d              ;516
00004c  d002              BEQ      |L27.84|
                  |L27.78|
00004e  4663              MOV      r3,r12                ;538
000050  e000              B        |L27.84|
                  |L27.82|
;;;541                {
;;;542                    u32div = (uint32_t)&CLK->CLKDIV4;
000052  4633              MOV      r3,r6
                  |L27.84|
;;;543                }
;;;544                else
;;;545                {
;;;546                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
;;;547                }
;;;548            }
;;;549    
;;;550            /* Apply new divider */
;;;551            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000054  681c              LDR      r4,[r3,#0]
000056  f3c02587          UBFX     r5,r0,#10,#8
00005a  f3c01644          UBFX     r6,r0,#5,#5
00005e  40b5              LSLS     r5,r5,r6
000060  43ac              BICS     r4,r4,r5
000062  4314              ORRS     r4,r4,r2
000064  601c              STR      r4,[r3,#0]
                  |L27.102|
;;;552        }
;;;553    
;;;554        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000066  0e42              LSRS     r2,r0,#25
000068  0752              LSLS     r2,r2,#29
00006a  d00e              BEQ      |L27.138|
;;;555        {
;;;556            /* Get clock select control register address */
;;;557            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4U);
00006c  4b08              LDR      r3,|L27.144|
00006e  f3c07201          UBFX     r2,r0,#28,#2
000072  3b18              SUBS     r3,r3,#0x18
000074  eb030282          ADD      r2,r3,r2,LSL #2
;;;558            /* Set new clock selection setting */
;;;559            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000078  6813              LDR      r3,[r2,#0]
00007a  f3c06442          UBFX     r4,r0,#25,#3
00007e  f3c05004          UBFX     r0,r0,#20,#5
000082  4084              LSLS     r4,r4,r0
000084  43a3              BICS     r3,r3,r4
000086  430b              ORRS     r3,r3,r1
000088  6013              STR      r3,[r2,#0]
                  |L27.138|
;;;560        }
;;;561    }
00008a  bdf0              POP      {r4-r7,pc}
;;;562    
                          ENDP

                  |L27.140|
                          DCD      0x4000022c
                  |L27.144|
                          DCD      0x40000228

                          AREA ||i.CLK_SetPowerDownMode||, CODE, READONLY, ALIGN=1

                  CLK_SetPowerDownMode PROC
;;;1042   
;;;1043   void CLK_SetPowerDownMode(uint32_t u32PDMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1044   {
;;;1045       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000002  f04f4580          MOV      r5,#0x40000000
000006  4604              MOV      r4,r0                 ;1044
000008  f8d501f4          LDR      r0,[r5,#0x1f4]
00000c  b2c0              UXTB     r0,r0
00000e  2801              CMP      r0,#1
000010  d004              BEQ      |L28.28|
;;;1046       {
;;;1047           if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD0)
;;;1048           {
;;;1049               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1050               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_16K;
;;;1051           }
;;;1052           else if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD1)
;;;1053           {
;;;1054               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1055               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_NO;
;;;1056           }
;;;1057       }
;;;1058       else
;;;1059       {
;;;1060           /* Enable LIRC clock before entering to Standby Power-down Mode */
;;;1061           if((u32PDMode == CLK_PMUCTL_PDMSEL_SPD0) || (u32PDMode == CLK_PMUCTL_PDMSEL_SPD1))
000012  2c04              CMP      r4,#4
000014  d016              BEQ      |L28.68|
000016  2c05              CMP      r4,#5
000018  d014              BEQ      |L28.68|
00001a  e01c              B        |L28.86|
                  |L28.28|
00001c  2c04              CMP      r4,#4                 ;1047
00001e  d002              BEQ      |L28.38|
000020  2c05              CMP      r4,#5                 ;1052
000022  d007              BEQ      |L28.52|
000024  e017              B        |L28.86|
                  |L28.38|
000026  f8d50290          LDR      r0,[r5,#0x290]        ;1050
00002a  f0200070          BIC      r0,r0,#0x70           ;1050
00002e  f0400010          ORR      r0,r0,#0x10           ;1050
000032  e004              B        |L28.62|
                  |L28.52|
000034  f8d50290          LDR      r0,[r5,#0x290]        ;1055
000038  2404              MOVS     r4,#4                 ;1054
00003a  f0200070          BIC      r0,r0,#0x70           ;1055
                  |L28.62|
00003e  f8c50290          STR      r0,[r5,#0x290]        ;1055
000042  e008              B        |L28.86|
                  |L28.68|
;;;1062           {
;;;1063               /* Enable LIRC clock */
;;;1064               CLK->PWRCTL |= CLK_PWRCTL_LIRCEN_Msk;
000044  f8d50200          LDR      r0,[r5,#0x200]
000048  f0400008          ORR      r0,r0,#8
00004c  f8c50200          STR      r0,[r5,#0x200]
;;;1065   
;;;1066               /* Wait for LIRC clock stable */
;;;1067               CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
000050  2008              MOVS     r0,#8
000052  f7fffffe          BL       CLK_WaitClockReady
                  |L28.86|
;;;1068           }
;;;1069       }
;;;1070   
;;;1071       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_PDMSEL_Msk)) | u32PDMode;
000056  f8d50290          LDR      r0,[r5,#0x290]
00005a  f0200007          BIC      r0,r0,#7
00005e  4320              ORRS     r0,r0,r4
000060  f8c50290          STR      r0,[r5,#0x290]
;;;1072   }
000064  bd30              POP      {r4,r5,pc}
;;;1073   
                          ENDP


                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=1

                  CLK_SetSysTickClockSrc PROC
;;;574      */
;;;575    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  f04f4180          MOV      r1,#0x40000000
;;;576    {
;;;577        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4302              ORRS     r2,r2,r0
00000e  f8c12210          STR      r2,[r1,#0x210]
;;;578    
;;;579    }
000012  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;960      */
;;;961    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b530              PUSH     {r4,r5,lr}
;;;962    {
;;;963        int32_t i32TimeOutCnt = 2160000;
;;;964        uint32_t u32Ret = 1U;
000002  2401              MOVS     r4,#1
000004  4605              MOV      r5,r0                 ;962
000006  4908              LDR      r1,|L30.40|
;;;965    
;;;966        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000008  07a2              LSLS     r2,r4,#30
00000a  e005              B        |L30.24|
                  |L30.12|
;;;967        {
;;;968            if(i32TimeOutCnt-- <= 0)
00000c  1e08              SUBS     r0,r1,#0
00000e  f1a10101          SUB      r1,r1,#1
000012  dc01              BGT      |L30.24|
;;;969            {
;;;970                u32Ret = 0U;
000014  2400              MOVS     r4,#0
;;;971                break;
000016  e004              B        |L30.34|
                  |L30.24|
000018  f8d23250          LDR      r3,[r2,#0x250]        ;966
00001c  ea350003          BICS     r0,r5,r3              ;966
000020  d1f4              BNE      |L30.12|
                  |L30.34|
;;;972            }
;;;973        }
;;;974        return u32Ret;
000022  4620              MOV      r0,r4
;;;975    }
000024  bd30              POP      {r4,r5,pc}
;;;976    
                          ENDP

000026  0000              DCW      0x0000
                  |L30.40|
                          DCD      0x0020f580

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000010

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____RRX|
#line 587
|__asm___5_clk_c_9b5832dc____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
