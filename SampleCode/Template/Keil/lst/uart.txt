; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_SPI_SLAVE --omf_browse=.\obj\uart.crf ..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;40     
;;;41     void UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag)
000000  054a              LSLS     r2,r1,#21
;;;42     {
000002  d503              BPL      |L1.12|
;;;43     
;;;44         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
;;;45         {
;;;46             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
000004  2270              MOVS     r2,#0x70
000006  6182              STR      r2,[r0,#0x18]
;;;47             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000008  2208              MOVS     r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L1.12|
;;;48         }
;;;49     
;;;50         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
00000c  050a              LSLS     r2,r1,#20
00000e  d503              BPL      |L1.24|
;;;51         {
;;;52             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
000010  6942              LDR      r2,[r0,#0x14]
000012  f0420201          ORR      r2,r2,#1
000016  6142              STR      r2,[r0,#0x14]
                  |L1.24|
;;;53         }
;;;54         else
;;;55         {
;;;56         }
;;;57     
;;;58         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000018  048a              LSLS     r2,r1,#18
00001a  d501              BPL      |L1.32|
;;;59         {
;;;60             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00001c  4a06              LDR      r2,|L1.56|
00001e  6182              STR      r2,[r0,#0x18]
                  |L1.32|
;;;61         }
;;;62     
;;;63         if(u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
000020  044a              LSLS     r2,r1,#17
000022  d501              BPL      |L1.40|
;;;64         {
;;;65             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
000024  221f              MOVS     r2,#0x1f
000026  6442              STR      r2,[r0,#0x44]
                  |L1.40|
;;;66                           UART_WKSTS_RFRTWKF_Msk |UART_WKSTS_RS485WKF_Msk |
;;;67                           UART_WKSTS_TOUTWKF_Msk;
;;;68         }
;;;69     
;;;70         if(u32InterruptFlag & UART_INTSTS_LININT_Msk)   /* Clear LIN Bus Interrupt */
000028  0409              LSLS     r1,r1,#16
00002a  d504              BPL      |L1.54|
;;;71         {
;;;72             uart->INTSTS = UART_INTSTS_LINIF_Msk;
00002c  2180              MOVS     r1,#0x80
00002e  61c1              STR      r1,[r0,#0x1c]
;;;73             uart->LINSTS = UART_LINSTS_BITEF_Msk    | UART_LINSTS_BRKDETF_Msk  |
000030  f240310f          MOV      r1,#0x30f
000034  6381              STR      r1,[r0,#0x38]
                  |L1.54|
;;;74                            UART_LINSTS_SLVSYNCF_Msk | UART_LINSTS_SLVIDPEF_Msk |
;;;75                            UART_LINSTS_SLVHEF_Msk   | UART_LINSTS_SLVHDETF_Msk ;
;;;76         }
;;;77     }
000036  4770              BX       lr
;;;78     
                          ENDP

                  |L1.56|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;88      */
;;;89     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;90     {
;;;91         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;92     }
000004  4770              BX       lr
;;;93     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;103     */
;;;104    void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;105    {
;;;106        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  f4215140          BIC      r1,r1,#0x3000
000006  6041              STR      r1,[r0,#4]
;;;107    }
000008  4770              BX       lr
;;;108    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;127     */
;;;128    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;129    {
;;;130        /* Disable UART specified interrupt */
;;;131        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;132    }
000006  4770              BX       lr
;;;133    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;143     */
;;;144    void UART_EnableFlowCtrl(UART_T* uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;145    {
;;;146        /* Set RTS pin output is low level active */
;;;147        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;148    
;;;149        /* Set CTS pin input is low level active */
;;;150        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000008  6941              LDR      r1,[r0,#0x14]
00000a  f4417180          ORR      r1,r1,#0x100
00000e  6141              STR      r1,[r0,#0x14]
;;;151    
;;;152        /* Set RTS and CTS auto flow control enable */
;;;153        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000010  6841              LDR      r1,[r0,#4]
000012  f4415140          ORR      r1,r1,#0x3000
000016  6041              STR      r1,[r0,#4]
;;;154    }
000018  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;174     */
;;;175    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;176    {
;;;177        /* Enable UART specified interrupt */
;;;178        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;179    }
000006  4770              BX       lr
;;;180    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;191     */
;;;192    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;193    {
000004  4604              MOV      r4,r0
;;;194        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;195        uint32_t u32ClkTbl[4] = {__HXT, 0ul, __LXT, __HIRC};
000006  483c              LDR      r0,|L7.248|
000008  460f              MOV      r7,r1                 ;193
00000a  2500              MOVS     r5,#0                 ;194
00000c  c80f              LDM      r0,{r0-r3}
00000e  e88d000f          STM      sp,{r0-r3}
;;;196        uint32_t u32Baud_Div = 0ul;
;;;197    
;;;198    
;;;199        if(uart==(UART_T*)UART0)
000012  493a              LDR      r1,|L7.252|
000014  462e              MOV      r6,r5                 ;194
;;;200        {
;;;201            /* Get UART clock source selection */
;;;202            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
000016  f04f4080          MOV      r0,#0x40000000
00001a  428c              CMP      r4,r1                 ;199
00001c  d106              BNE      |L7.44|
00001e  f8d01214          LDR      r1,[r0,#0x214]
;;;203            /* Get UART clock divider number */
;;;204            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000022  f8d00220          LDR      r0,[r0,#0x220]
000026  f3c16501          UBFX     r5,r1,#24,#2          ;202
00002a  e02a              B        |L7.130|
                  |L7.44|
;;;205        }
;;;206        else if(uart==(UART_T*)UART1)
00002c  4934              LDR      r1,|L7.256|
00002e  428c              CMP      r4,r1
000030  d106              BNE      |L7.64|
;;;207        {
;;;208            /* Get UART clock source selection */
;;;209            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000032  f8d01214          LDR      r1,[r0,#0x214]
;;;210            /* Get UART clock divider number */
;;;211            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
000036  f8d00220          LDR      r0,[r0,#0x220]
00003a  f3c16581          UBFX     r5,r1,#26,#2          ;209
00003e  e02b              B        |L7.152|
                  |L7.64|
;;;212        }
;;;213        else if(uart==(UART_T*)UART2)
000040  4930              LDR      r1,|L7.260|
000042  428c              CMP      r4,r1
000044  d108              BNE      |L7.88|
;;;214        {
;;;215            /* Get UART clock source selection */
;;;216            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000046  f8d0121c          LDR      r1,[r0,#0x21c]
;;;217            /* Get UART clock divider number */
;;;218            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
00004a  f8d00230          LDR      r0,[r0,#0x230]
00004e  f3c16501          UBFX     r5,r1,#24,#2          ;216
000052  f000060f          AND      r6,r0,#0xf
000056  e021              B        |L7.156|
                  |L7.88|
;;;219        }
;;;220        else if(uart==(UART_T*)UART3)
000058  492b              LDR      r1,|L7.264|
00005a  428c              CMP      r4,r1
00005c  d108              BNE      |L7.112|
;;;221        {
;;;222            /* Get UART clock source selection */
;;;223            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
00005e  f8d0121c          LDR      r1,[r0,#0x21c]
;;;224            /* Get UART clock divider number */
;;;225            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000062  f8d00230          LDR      r0,[r0,#0x230]
000066  f3c16581          UBFX     r5,r1,#26,#2          ;223
00006a  f3c01603          UBFX     r6,r0,#4,#4
00006e  e015              B        |L7.156|
                  |L7.112|
;;;226        }
;;;227        else if(uart==(UART_T*)UART4)
000070  4926              LDR      r1,|L7.268|
000072  428c              CMP      r4,r1
000074  d108              BNE      |L7.136|
;;;228        {
;;;229            /* Get UART clock source selection */
;;;230            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
000076  f8d0121c          LDR      r1,[r0,#0x21c]
;;;231            /* Get UART clock divider number */
;;;232            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
00007a  f8d00230          LDR      r0,[r0,#0x230]
00007e  f3c17501          UBFX     r5,r1,#28,#2          ;230
                  |L7.130|
000082  f3c02603          UBFX     r6,r0,#8,#4
000086  e009              B        |L7.156|
                  |L7.136|
;;;233        }
;;;234        else if(uart==(UART_T*)UART5)
000088  4921              LDR      r1,|L7.272|
00008a  428c              CMP      r4,r1
00008c  d106              BNE      |L7.156|
;;;235        {
;;;236            /* Get UART clock source selection */
;;;237            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
00008e  f8d0121c          LDR      r1,[r0,#0x21c]
;;;238            /* Get UART clock divider number */
;;;239            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
000092  f8d00230          LDR      r0,[r0,#0x230]
000096  0f8d              LSRS     r5,r1,#30             ;237
                  |L7.152|
000098  f3c03603          UBFX     r6,r0,#12,#4
                  |L7.156|
;;;240        }
;;;241    
;;;242        /* Select UART function */
;;;243        uart->FUNCSEL = UART_FUNCSEL_UART;
00009c  2000              MOVS     r0,#0
00009e  6320              STR      r0,[r4,#0x30]
;;;244    
;;;245        /* Set UART line configuration */
;;;246        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
0000a0  2003              MOVS     r0,#3
0000a2  60e0              STR      r0,[r4,#0xc]
;;;247    
;;;248        /* Set UART Rx and RTS trigger level */
;;;249        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
0000a4  68a0              LDR      r0,[r4,#8]
0000a6  491b              LDR      r1,|L7.276|
0000a8  4008              ANDS     r0,r0,r1
0000aa  60a0              STR      r0,[r4,#8]
0000ac  46e8              MOV      r8,sp                 ;195
;;;250    
;;;251        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;252        if(u32UartClkSrcSel == 1ul)
0000ae  2d01              CMP      r5,#1
0000b0  d102              BNE      |L7.184|
;;;253        {
;;;254            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000b2  f7fffffe          BL       CLK_GetPLLClockFreq
0000b6  9001              STR      r0,[sp,#4]
                  |L7.184|
;;;255        }
;;;256    
;;;257        /* Set UART baud rate */
;;;258        if(u32baudrate != 0ul)
0000b8  2f00              CMP      r7,#0
0000ba  d01a              BEQ      |L7.242|
;;;259        {
;;;260            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
0000bc  f8581025          LDR      r1,[r8,r5,LSL #2]
0000c0  1c76              ADDS     r6,r6,#1
0000c2  fbb1f0f6          UDIV     r0,r1,r6
0000c6  eb000057          ADD      r0,r0,r7,LSR #1
0000ca  fbb0f0f7          UDIV     r0,r0,r7
0000ce  1e80              SUBS     r0,r0,#2
;;;261    
;;;262            if(u32Baud_Div > 0xFFFFul)
0000d0  f5b03f80          CMP      r0,#0x10000
0000d4  d30a              BCC      |L7.236|
;;;263            {
;;;264                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
0000d6  fbb1f0f6          UDIV     r0,r1,r6
0000da  eb0000c7          ADD      r0,r0,r7,LSL #3
0000de  fbb0f0f7          UDIV     r0,r0,r7
0000e2  f06f0101          MVN      r1,#1
0000e6  eb011010          ADD      r0,r1,r0,LSR #4
0000ea  e001              B        |L7.240|
                  |L7.236|
;;;265            }
;;;266            else
;;;267            {
;;;268                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
0000ec  f0405040          ORR      r0,r0,#0x30000000
                  |L7.240|
0000f0  6260              STR      r0,[r4,#0x24]
                  |L7.242|
;;;269            }
;;;270        }
;;;271    }
0000f2  e8bd81ff          POP      {r0-r8,pc}
;;;272    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L7.248|
                          DCD      ||.constdata||
                  |L7.252|
                          DCD      0x40070000
                  |L7.256|
                          DCD      0x40071000
                  |L7.260|
                          DCD      0x40072000
                  |L7.264|
                          DCD      0x40073000
                  |L7.268|
                          DCD      0x40074000
                  |L7.272|
                          DCD      0x40075000
                  |L7.276|
                          DCD      0xfff0ff0f

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;284     */
;;;285    uint32_t UART_Read(UART_T* uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;286    {
000002  4604              MOV      r4,r0
;;;287        uint32_t  u32Count, u32delayno;
;;;288        uint32_t  u32Exit = 0ul;
000004  2600              MOVS     r6,#0
;;;289    
;;;290        for(u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
000006  4630              MOV      r0,r6
;;;291        {
;;;292            u32delayno = 0ul;
;;;293    
;;;294            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;295            {
;;;296                u32delayno++;
;;;297                if(u32delayno >= 0x40000000ul)
000008  f04f4580          MOV      r5,#0x40000000
00000c  e00c              B        |L8.40|
                  |L8.14|
00000e  2300              MOVS     r3,#0                 ;292
000010  e002              B        |L8.24|
                  |L8.18|
000012  1c5b              ADDS     r3,r3,#1              ;294
000014  42ab              CMP      r3,r5
000016  d209              BCS      |L8.44|
                  |L8.24|
000018  69a7              LDR      r7,[r4,#0x18]         ;294
00001a  047f              LSLS     r7,r7,#17             ;294
00001c  d4f9              BMI      |L8.18|
;;;298                {
;;;299                    u32Exit = 1ul;
;;;300                    break;
;;;301                }
;;;302                else
;;;303                {
;;;304                }
;;;305            }
;;;306    
;;;307            if(u32Exit == 1ul)
00001e  2e00              CMP      r6,#0
000020  d104              BNE      |L8.44|
;;;308            {
;;;309                break;
;;;310            }
;;;311            else
;;;312            {
;;;313                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
000022  6823              LDR      r3,[r4,#0]
000024  540b              STRB     r3,[r1,r0]
000026  1c40              ADDS     r0,r0,#1
                  |L8.40|
000028  4290              CMP      r0,r2                 ;290
00002a  d3f0              BCC      |L8.14|
                  |L8.44|
;;;314            }
;;;315        }
;;;316    
;;;317        return u32Count;
;;;318    
;;;319    }
00002c  bdf0              POP      {r4-r7,pc}
;;;320    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;459     */
;;;460    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;461    {
000004  4604              MOV      r4,r0
;;;462        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;463        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000006  483c              LDR      r0,|L9.248|
000008  4691              MOV      r9,r2                 ;461
00000a  460f              MOV      r7,r1                 ;461
00000c  c80f              LDM      r0,{r0-r3}
00000e  e88d000f          STM      sp,{r0-r3}
000012  2500              MOVS     r5,#0                 ;462
;;;464        uint32_t u32Baud_Div;
;;;465    
;;;466        /* Select IrDA function mode */
;;;467        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000014  2002              MOVS     r0,#2
000016  462e              MOV      r6,r5                 ;462
000018  6320              STR      r0,[r4,#0x30]
;;;468    
;;;469    
;;;470        if(uart==UART0)
00001a  4938              LDR      r1,|L9.252|
;;;471        {
;;;472            /* Get UART clock source selection */
;;;473            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001c  0740              LSLS     r0,r0,#29
00001e  46e8              MOV      r8,sp                 ;463
000020  428c              CMP      r4,r1                 ;470
000022  d106              BNE      |L9.50|
000024  f8d01214          LDR      r1,[r0,#0x214]
;;;474            /* Get UART clock divider number */
;;;475            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000028  f8d00220          LDR      r0,[r0,#0x220]
00002c  f3c16501          UBFX     r5,r1,#24,#2          ;473
000030  e02a              B        |L9.136|
                  |L9.50|
;;;476        }
;;;477        else if(uart==UART1)
000032  4933              LDR      r1,|L9.256|
000034  428c              CMP      r4,r1
000036  d106              BNE      |L9.70|
;;;478        {
;;;479            /* Get UART clock source selection */
;;;480            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000038  f8d01214          LDR      r1,[r0,#0x214]
;;;481            /* Get UART clock divider number */
;;;482            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
00003c  f8d00220          LDR      r0,[r0,#0x220]
000040  f3c16581          UBFX     r5,r1,#26,#2          ;480
000044  e02b              B        |L9.158|
                  |L9.70|
;;;483        }
;;;484        else if(uart==UART2)
000046  492f              LDR      r1,|L9.260|
000048  428c              CMP      r4,r1
00004a  d108              BNE      |L9.94|
;;;485        {
;;;486            /* Get UART clock source selection */
;;;487            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
00004c  f8d0121c          LDR      r1,[r0,#0x21c]
;;;488            /* Get UART clock divider number */
;;;489            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000050  f8d00230          LDR      r0,[r0,#0x230]
000054  f3c16501          UBFX     r5,r1,#24,#2          ;487
000058  f000060f          AND      r6,r0,#0xf
00005c  e021              B        |L9.162|
                  |L9.94|
;;;490        }
;;;491        else if(uart==UART3)
00005e  492a              LDR      r1,|L9.264|
000060  428c              CMP      r4,r1
000062  d108              BNE      |L9.118|
;;;492        {
;;;493            /* Get UART clock source selection */
;;;494            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000064  f8d0121c          LDR      r1,[r0,#0x21c]
;;;495            /* Get UART clock divider number */
;;;496            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000068  f8d00230          LDR      r0,[r0,#0x230]
00006c  f3c16581          UBFX     r5,r1,#26,#2          ;494
000070  f3c01603          UBFX     r6,r0,#4,#4
000074  e015              B        |L9.162|
                  |L9.118|
;;;497        }
;;;498        else if(uart==UART4)
000076  4925              LDR      r1,|L9.268|
000078  428c              CMP      r4,r1
00007a  d108              BNE      |L9.142|
;;;499        {
;;;500            /* Get UART clock source selection */
;;;501            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
00007c  f8d0121c          LDR      r1,[r0,#0x21c]
;;;502            /* Get UART clock divider number */
;;;503            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
000080  f8d00230          LDR      r0,[r0,#0x230]
000084  f3c17501          UBFX     r5,r1,#28,#2          ;501
                  |L9.136|
000088  f3c02603          UBFX     r6,r0,#8,#4
00008c  e009              B        |L9.162|
                  |L9.142|
;;;504        }
;;;505        else if(uart==UART5)
00008e  4920              LDR      r1,|L9.272|
000090  428c              CMP      r4,r1
000092  d10b              BNE      |L9.172|
;;;506        {
;;;507            /* Get UART clock source selection */
;;;508            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
000094  f8d0121c          LDR      r1,[r0,#0x21c]
;;;509            /* Get UART clock divider number */
;;;510            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
000098  f8d00230          LDR      r0,[r0,#0x230]
00009c  0f8d              LSRS     r5,r1,#30             ;508
                  |L9.158|
00009e  f3c03603          UBFX     r6,r0,#12,#4
                  |L9.162|
;;;511        }
;;;512    
;;;513    
;;;514        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;515        if(u32UartClkSrcSel == 1ul)
0000a2  2d01              CMP      r5,#1
0000a4  d102              BNE      |L9.172|
;;;516        {
;;;517            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000a6  f7fffffe          BL       CLK_GetPLLClockFreq
0000aa  9001              STR      r0,[sp,#4]
                  |L9.172|
;;;518        }
;;;519        else
;;;520        {
;;;521        }
;;;522    
;;;523        /* Set UART IrDA baud rate in mode 0 */
;;;524        if(u32Buadrate != 0ul)
0000ac  b187              CBZ      r7,|L9.208|
;;;525        {
;;;526            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
0000ae  f8580025          LDR      r0,[r8,r5,LSL #2]
0000b2  1c76              ADDS     r6,r6,#1
0000b4  fbb0f0f6          UDIV     r0,r0,r6
0000b8  eb0000c7          ADD      r0,r0,r7,LSL #3
0000bc  fbb0f0f7          UDIV     r0,r0,r7
0000c0  f06f0101          MVN      r1,#1
0000c4  eb011010          ADD      r0,r1,r0,LSR #4
;;;527    
;;;528            if(u32Baud_Div < 0xFFFFul)
0000c8  0c09              LSRS     r1,r1,#16
0000ca  4288              CMP      r0,r1
0000cc  d200              BCS      |L9.208|
;;;529            {
;;;530                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
0000ce  6260              STR      r0,[r4,#0x24]
                  |L9.208|
;;;531            }
;;;532            else
;;;533            {
;;;534            }
;;;535        }
;;;536    
;;;537        /* Configure IrDA relative settings */
;;;538        if(u32Direction == UART_IRDA_RXEN)
;;;539        {
;;;540            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
;;;541            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;542        }
;;;543        else
;;;544        {
;;;545            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
0000d0  6aa0              LDR      r0,[r4,#0x28]
0000d2  f1b90f00          CMP      r9,#0                 ;538
0000d6  d008              BEQ      |L9.234|
0000d8  f0200020          BIC      r0,r0,#0x20
0000dc  62a0              STR      r0,[r4,#0x28]
;;;546            uart->IRDA |= UART_IRDA_TXEN_Msk;
0000de  6aa0              LDR      r0,[r4,#0x28]
0000e0  f0400002          ORR      r0,r0,#2
                  |L9.228|
0000e4  62a0              STR      r0,[r4,#0x28]         ;541
;;;547        }
;;;548    
;;;549    }
0000e6  e8bd87ff          POP      {r0-r10,pc}
                  |L9.234|
0000ea  f0400040          ORR      r0,r0,#0x40           ;540
0000ee  62a0              STR      r0,[r4,#0x28]         ;540
0000f0  6aa0              LDR      r0,[r4,#0x28]         ;541
0000f2  f0200002          BIC      r0,r0,#2              ;541
0000f6  e7f5              B        |L9.228|
;;;550    
                          ENDP

                  |L9.248|
                          DCD      ||.constdata||+0x20
                  |L9.252|
                          DCD      0x40070000
                  |L9.256|
                          DCD      0x40071000
                  |L9.260|
                          DCD      0x40072000
                  |L9.264|
                          DCD      0x40073000
                  |L9.268|
                          DCD      0x40074000
                  |L9.272|
                          DCD      0x40075000

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;589     */
;;;590    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  2301              MOVS     r3,#1
;;;591    {
;;;592        /* Select LIN function mode */
;;;593        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  6303              STR      r3,[r0,#0x30]
;;;594    
;;;595        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;596        uart->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000004  6ac3              LDR      r3,[r0,#0x2c]
000006  f02303cf          BIC      r3,r3,#0xcf
00000a  62c3              STR      r3,[r0,#0x2c]
;;;597        uart->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000c  6ac3              LDR      r3,[r0,#0x2c]
00000e  4311              ORRS     r1,r1,r2
000010  430b              ORRS     r3,r3,r1
000012  62c3              STR      r3,[r0,#0x2c]
;;;598    }
000014  4770              BX       lr
;;;599    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;565     */
;;;566    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;567    {
;;;568        /* Select UART RS485 function mode */
;;;569        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;570    
;;;571        /* Set RS585 configuration */
;;;572        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L11.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;573        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  ea416102          ORR      r1,r1,r2,LSL #24
000014  430b              ORRS     r3,r3,r1
000016  62c3              STR      r3,[r0,#0x2c]
;;;574    }
000018  bd10              POP      {r4,pc}
;;;575    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SetLineConfig||, CODE, READONLY, ALIGN=2

                  UART_SetLineConfig PROC
;;;347     */
;;;348    void UART_SetLineConfig(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;349    {
000004  4604              MOV      r4,r0
;;;350        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;351        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000006  483c              LDR      r0,|L12.248|
000008  469a              MOV      r10,r3                ;349
00000a  4691              MOV      r9,r2                 ;349
00000c  460f              MOV      r7,r1                 ;349
00000e  c80f              LDM      r0,{r0-r3}
000010  f8ddb038          LDR      r11,[sp,#0x38]
000014  e88d000f          STM      sp,{r0-r3}
000018  2500              MOVS     r5,#0                 ;350
;;;352        uint32_t u32Baud_Div = 0ul;
;;;353    
;;;354    
;;;355        if(uart==(UART_T*)UART0)
00001a  4938              LDR      r1,|L12.252|
00001c  462e              MOV      r6,r5                 ;350
;;;356        {
;;;357            /* Get UART clock source selection */
;;;358            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001e  f04f4080          MOV      r0,#0x40000000
000022  46e8              MOV      r8,sp                 ;351
000024  428c              CMP      r4,r1                 ;355
000026  d106              BNE      |L12.54|
000028  f8d01214          LDR      r1,[r0,#0x214]
;;;359            /* Get UART clock divider number */
;;;360            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
00002c  f8d00220          LDR      r0,[r0,#0x220]
000030  f3c16501          UBFX     r5,r1,#24,#2          ;358
000034  e02a              B        |L12.140|
                  |L12.54|
;;;361        }
;;;362        else if(uart==(UART_T*)UART1)
000036  4932              LDR      r1,|L12.256|
000038  428c              CMP      r4,r1
00003a  d106              BNE      |L12.74|
;;;363        {
;;;364            /* Get UART clock source selection */
;;;365            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
00003c  f8d01214          LDR      r1,[r0,#0x214]
;;;366            /* Get UART clock divider number */
;;;367            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
000040  f8d00220          LDR      r0,[r0,#0x220]
000044  f3c16581          UBFX     r5,r1,#26,#2          ;365
000048  e02b              B        |L12.162|
                  |L12.74|
;;;368        }
;;;369        else if(uart==(UART_T*)UART2)
00004a  492e              LDR      r1,|L12.260|
00004c  428c              CMP      r4,r1
00004e  d108              BNE      |L12.98|
;;;370        {
;;;371            /* Get UART clock source selection */
;;;372            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000050  f8d0121c          LDR      r1,[r0,#0x21c]
;;;373            /* Get UART clock divider number */
;;;374            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000054  f8d00230          LDR      r0,[r0,#0x230]
000058  f3c16501          UBFX     r5,r1,#24,#2          ;372
00005c  f000060f          AND      r6,r0,#0xf
000060  e021              B        |L12.166|
                  |L12.98|
;;;375        }
;;;376        else if(uart==(UART_T*)UART3)
000062  4929              LDR      r1,|L12.264|
000064  428c              CMP      r4,r1
000066  d108              BNE      |L12.122|
;;;377        {
;;;378            /* Get UART clock source selection */
;;;379            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000068  f8d0121c          LDR      r1,[r0,#0x21c]
;;;380            /* Get UART clock divider number */
;;;381            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
00006c  f8d00230          LDR      r0,[r0,#0x230]
000070  f3c16581          UBFX     r5,r1,#26,#2          ;379
000074  f3c01603          UBFX     r6,r0,#4,#4
000078  e015              B        |L12.166|
                  |L12.122|
;;;382        }
;;;383        else if(uart==(UART_T*)UART4)
00007a  4924              LDR      r1,|L12.268|
00007c  428c              CMP      r4,r1
00007e  d108              BNE      |L12.146|
;;;384        {
;;;385            /* Get UART clock source selection */
;;;386            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
000080  f8d0121c          LDR      r1,[r0,#0x21c]
;;;387            /* Get UART clock divider number */
;;;388            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
000084  f8d00230          LDR      r0,[r0,#0x230]
000088  f3c17501          UBFX     r5,r1,#28,#2          ;386
                  |L12.140|
00008c  f3c02603          UBFX     r6,r0,#8,#4
000090  e009              B        |L12.166|
                  |L12.146|
;;;389        }
;;;390        else if(uart==(UART_T*)UART5)
000092  491f              LDR      r1,|L12.272|
000094  428c              CMP      r4,r1
000096  d10b              BNE      |L12.176|
;;;391        {
;;;392            /* Get UART clock source selection */
;;;393            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
000098  f8d0121c          LDR      r1,[r0,#0x21c]
;;;394            /* Get UART clock divider number */
;;;395            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
00009c  f8d00230          LDR      r0,[r0,#0x230]
0000a0  0f8d              LSRS     r5,r1,#30             ;393
                  |L12.162|
0000a2  f3c03603          UBFX     r6,r0,#12,#4
                  |L12.166|
;;;396        }
;;;397    
;;;398        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;399        if(u32UartClkSrcSel == 1ul)
0000a6  2d01              CMP      r5,#1
0000a8  d102              BNE      |L12.176|
;;;400        {
;;;401            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000aa  f7fffffe          BL       CLK_GetPLLClockFreq
0000ae  9001              STR      r0,[sp,#4]
                  |L12.176|
;;;402        }
;;;403        else
;;;404        {
;;;405        }
;;;406    
;;;407        /* Set UART baud rate */
;;;408        if(u32baudrate != 0ul)
0000b0  b1d7              CBZ      r7,|L12.232|
;;;409        {
;;;410            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
0000b2  f8581025          LDR      r1,[r8,r5,LSL #2]
0000b6  1c76              ADDS     r6,r6,#1
0000b8  fbb1f0f6          UDIV     r0,r1,r6
0000bc  eb000057          ADD      r0,r0,r7,LSR #1
0000c0  fbb0f0f7          UDIV     r0,r0,r7
0000c4  1e80              SUBS     r0,r0,#2
;;;411    
;;;412            if(u32Baud_Div > 0xFFFFul)
0000c6  f5b03f80          CMP      r0,#0x10000
0000ca  d30a              BCC      |L12.226|
;;;413            {
;;;414                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
0000cc  fbb1f0f6          UDIV     r0,r1,r6
0000d0  eb0000c7          ADD      r0,r0,r7,LSL #3
0000d4  fbb0f0f7          UDIV     r0,r0,r7
0000d8  f06f0101          MVN      r1,#1
0000dc  eb011010          ADD      r0,r1,r0,LSR #4
0000e0  e001              B        |L12.230|
                  |L12.226|
;;;415            }
;;;416            else
;;;417            {
;;;418                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
0000e2  f0405040          ORR      r0,r0,#0x30000000
                  |L12.230|
0000e6  6260              STR      r0,[r4,#0x24]         ;414
                  |L12.232|
;;;419            }
;;;420        }
;;;421    
;;;422        /* Set UART line configuration */
;;;423        uart->LINE = u32data_width | u32parity | u32stop_bits;
0000e8  ea49000a          ORR      r0,r9,r10
0000ec  ea40000b          ORR      r0,r0,r11
0000f0  60e0              STR      r0,[r4,#0xc]
;;;424    }
0000f2  e8bd9fff          POP      {r0-r12,pc}
;;;425    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L12.248|
                          DCD      ||.constdata||+0x10
                  |L12.252|
                          DCD      0x40070000
                  |L12.256|
                          DCD      0x40071000
                  |L12.260|
                          DCD      0x40072000
                  |L12.264|
                          DCD      0x40073000
                  |L12.268|
                          DCD      0x40074000
                  |L12.272|
                          DCD      0x40075000

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;436     */
;;;437    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;438    {
;;;439        /* Set time-out interrupt comparator */
;;;440        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  f02202ff          BIC      r2,r2,#0xff
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;441    
;;;442        /* Set time-out counter enable */
;;;443        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  f4416100          ORR      r1,r1,#0x800
000010  6041              STR      r1,[r0,#4]
;;;444    }
000012  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;611     */
;;;612    uint32_t UART_Write(UART_T* uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;613    {
000002  4604              MOV      r4,r0
;;;614        uint32_t  u32Count, u32delayno;
;;;615        uint32_t  u32Exit = 0ul;
000004  2600              MOVS     r6,#0
;;;616    
;;;617        for(u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
000006  4630              MOV      r0,r6
;;;618        {
;;;619            u32delayno = 0ul;
;;;620            while(uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)   /* Check Tx Full */
;;;621            {
;;;622                u32delayno++;
;;;623                if(u32delayno >= 0x40000000ul)
000008  f04f4580          MOV      r5,#0x40000000
00000c  e00c              B        |L14.40|
                  |L14.14|
00000e  2300              MOVS     r3,#0                 ;619
000010  e002              B        |L14.24|
                  |L14.18|
000012  1c5b              ADDS     r3,r3,#1              ;620
000014  42ab              CMP      r3,r5
000016  d209              BCS      |L14.44|
                  |L14.24|
000018  69a7              LDR      r7,[r4,#0x18]         ;620
00001a  023f              LSLS     r7,r7,#8              ;620
00001c  d4f9              BMI      |L14.18|
;;;624                {
;;;625                    u32Exit = 1ul;
;;;626                    break;
;;;627                }
;;;628                else
;;;629                {
;;;630                }
;;;631            }
;;;632    
;;;633            if(u32Exit == 1ul)
00001e  2e00              CMP      r6,#0
000020  d104              BNE      |L14.44|
;;;634            {
;;;635                break;
;;;636            }
;;;637            else
;;;638            {
;;;639                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
000022  5c0b              LDRB     r3,[r1,r0]
000024  6023              STR      r3,[r4,#0]
000026  1c40              ADDS     r0,r0,#1
                  |L14.40|
000028  4290              CMP      r0,r2                 ;617
00002a  d1f0              BNE      |L14.14|
                  |L14.44|
;;;640            }
;;;641        }
;;;642    
;;;643        return u32Count;
;;;644    }
00002c  bdf0              POP      {r4-r7,pc}
;;;645    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____RRX|
#line 587
|__asm___6_uart_c_f12f5b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
