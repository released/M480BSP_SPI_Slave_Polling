; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_SPI_SLAVE --omf_browse=.\obj\spi.crf ..\..\..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.SPII2S_Close||, CODE, READONLY, ALIGN=1

                  SPII2S_Close PROC
;;;1239     */
;;;1240   void SPII2S_Close(SPI_T *i2s)
000000  6e01              LDR      r1,[r0,#0x60]
;;;1241   {
;;;1242       i2s->I2SCTL &= ~SPI_I2SCTL_I2SEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  6601              STR      r1,[r0,#0x60]
;;;1243   }
000008  4770              BX       lr
;;;1244   
                          ENDP


                          AREA ||i.SPII2S_DisableInt||, CODE, READONLY, ALIGN=1

                  SPII2S_DisableInt PROC
;;;1319     */
;;;1320   void SPII2S_DisableInt(SPI_T *i2s, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;1321   {
000002  d003              BEQ      |L2.12|
;;;1322       /* Disable TX threshold interrupt flag */
;;;1323       if((u32Mask & SPII2S_FIFO_TXTH_INT_MASK) == SPII2S_FIFO_TXTH_INT_MASK)
;;;1324       {
;;;1325           i2s->FIFOCTL &= ~SPI_FIFOCTL_TXTHIEN_Msk;
000004  6902              LDR      r2,[r0,#0x10]
000006  f0220208          BIC      r2,r2,#8
00000a  6102              STR      r2,[r0,#0x10]
                  |L2.12|
;;;1326       }
;;;1327   
;;;1328       /* Disable RX threshold interrupt flag */
;;;1329       if((u32Mask & SPII2S_FIFO_RXTH_INT_MASK) == SPII2S_FIFO_RXTH_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L2.24|
;;;1330       {
;;;1331           i2s->FIFOCTL &= ~SPI_FIFOCTL_RXTHIEN_Msk;
000010  6902              LDR      r2,[r0,#0x10]
000012  f0220204          BIC      r2,r2,#4
000016  6102              STR      r2,[r0,#0x10]
                  |L2.24|
;;;1332       }
;;;1333   
;;;1334       /* Disable RX overrun interrupt flag */
;;;1335       if((u32Mask & SPII2S_FIFO_RXOV_INT_MASK) == SPII2S_FIFO_RXOV_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L2.36|
;;;1336       {
;;;1337           i2s->FIFOCTL &= ~SPI_FIFOCTL_RXOVIEN_Msk;
00001c  6902              LDR      r2,[r0,#0x10]
00001e  f0220220          BIC      r2,r2,#0x20
000022  6102              STR      r2,[r0,#0x10]
                  |L2.36|
;;;1338       }
;;;1339   
;;;1340       /* Disable RX time-out interrupt flag */
;;;1341       if((u32Mask & SPII2S_FIFO_RXTO_INT_MASK) == SPII2S_FIFO_RXTO_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L2.48|
;;;1342       {
;;;1343           i2s->FIFOCTL &= ~SPI_FIFOCTL_RXTOIEN_Msk;
000028  6902              LDR      r2,[r0,#0x10]
00002a  f0220210          BIC      r2,r2,#0x10
00002e  6102              STR      r2,[r0,#0x10]
                  |L2.48|
;;;1344       }
;;;1345   
;;;1346       /* Disable TX underflow interrupt flag */
;;;1347       if((u32Mask & SPII2S_TXUF_INT_MASK) == SPII2S_TXUF_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L2.60|
;;;1348       {
;;;1349           i2s->FIFOCTL &= ~SPI_FIFOCTL_TXUFIEN_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  f0220280          BIC      r2,r2,#0x80
00003a  6102              STR      r2,[r0,#0x10]
                  |L2.60|
;;;1350       }
;;;1351   
;;;1352       /* Disable right channel zero cross interrupt flag */
;;;1353       if((u32Mask & SPII2S_RIGHT_ZC_INT_MASK) == SPII2S_RIGHT_ZC_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L2.72|
;;;1354       {
;;;1355           i2s->I2SCTL &= ~SPI_I2SCTL_RZCIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  f0227280          BIC      r2,r2,#0x1000000
000046  6602              STR      r2,[r0,#0x60]
                  |L2.72|
;;;1356       }
;;;1357   
;;;1358       /* Disable left channel zero cross interrupt flag */
;;;1359       if((u32Mask & SPII2S_LEFT_ZC_INT_MASK) == SPII2S_LEFT_ZC_INT_MASK)
000048  0649              LSLS     r1,r1,#25
00004a  d503              BPL      |L2.84|
;;;1360       {
;;;1361           i2s->I2SCTL &= ~SPI_I2SCTL_LZCIEN_Msk;
00004c  6e01              LDR      r1,[r0,#0x60]
00004e  f0217100          BIC      r1,r1,#0x2000000
000052  6601              STR      r1,[r0,#0x60]
                  |L2.84|
;;;1362       }
;;;1363   }
000054  4770              BX       lr
;;;1364   
                          ENDP


                          AREA ||i.SPII2S_DisableMCLK||, CODE, READONLY, ALIGN=1

                  SPII2S_DisableMCLK PROC
;;;1416     */
;;;1417   void SPII2S_DisableMCLK(SPI_T *i2s)
000000  6e01              LDR      r1,[r0,#0x60]
;;;1418   {
;;;1419       i2s->I2SCTL &= ~SPI_I2SCTL_MCLKEN_Msk;
000002  f4214100          BIC      r1,r1,#0x8000
000006  6601              STR      r1,[r0,#0x60]
;;;1420   }
000008  4770              BX       lr
;;;1421   
                          ENDP


                          AREA ||i.SPII2S_EnableInt||, CODE, READONLY, ALIGN=1

                  SPII2S_EnableInt PROC
;;;1259     */
;;;1260   void SPII2S_EnableInt(SPI_T *i2s, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;1261   {
000002  d003              BEQ      |L4.12|
;;;1262       /* Enable TX threshold interrupt flag */
;;;1263       if((u32Mask & SPII2S_FIFO_TXTH_INT_MASK) == SPII2S_FIFO_TXTH_INT_MASK)
;;;1264       {
;;;1265           i2s->FIFOCTL |= SPI_FIFOCTL_TXTHIEN_Msk;
000004  6902              LDR      r2,[r0,#0x10]
000006  f0420208          ORR      r2,r2,#8
00000a  6102              STR      r2,[r0,#0x10]
                  |L4.12|
;;;1266       }
;;;1267   
;;;1268       /* Enable RX threshold interrupt flag */
;;;1269       if((u32Mask & SPII2S_FIFO_RXTH_INT_MASK) == SPII2S_FIFO_RXTH_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L4.24|
;;;1270       {
;;;1271           i2s->FIFOCTL |= SPI_FIFOCTL_RXTHIEN_Msk;
000010  6902              LDR      r2,[r0,#0x10]
000012  f0420204          ORR      r2,r2,#4
000016  6102              STR      r2,[r0,#0x10]
                  |L4.24|
;;;1272       }
;;;1273   
;;;1274       /* Enable RX overrun interrupt flag */
;;;1275       if((u32Mask & SPII2S_FIFO_RXOV_INT_MASK) == SPII2S_FIFO_RXOV_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L4.36|
;;;1276       {
;;;1277           i2s->FIFOCTL |= SPI_FIFOCTL_RXOVIEN_Msk;
00001c  6902              LDR      r2,[r0,#0x10]
00001e  f0420220          ORR      r2,r2,#0x20
000022  6102              STR      r2,[r0,#0x10]
                  |L4.36|
;;;1278       }
;;;1279   
;;;1280       /* Enable RX time-out interrupt flag */
;;;1281       if((u32Mask & SPII2S_FIFO_RXTO_INT_MASK) == SPII2S_FIFO_RXTO_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L4.48|
;;;1282       {
;;;1283           i2s->FIFOCTL |= SPI_FIFOCTL_RXTOIEN_Msk;
000028  6902              LDR      r2,[r0,#0x10]
00002a  f0420210          ORR      r2,r2,#0x10
00002e  6102              STR      r2,[r0,#0x10]
                  |L4.48|
;;;1284       }
;;;1285   
;;;1286       /* Enable TX underflow interrupt flag */
;;;1287       if((u32Mask & SPII2S_TXUF_INT_MASK) == SPII2S_TXUF_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L4.60|
;;;1288       {
;;;1289           i2s->FIFOCTL |= SPI_FIFOCTL_TXUFIEN_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  f0420280          ORR      r2,r2,#0x80
00003a  6102              STR      r2,[r0,#0x10]
                  |L4.60|
;;;1290       }
;;;1291   
;;;1292       /* Enable right channel zero cross interrupt flag */
;;;1293       if((u32Mask & SPII2S_RIGHT_ZC_INT_MASK) == SPII2S_RIGHT_ZC_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L4.72|
;;;1294       {
;;;1295           i2s->I2SCTL |= SPI_I2SCTL_RZCIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  f0427280          ORR      r2,r2,#0x1000000
000046  6602              STR      r2,[r0,#0x60]
                  |L4.72|
;;;1296       }
;;;1297   
;;;1298       /* Enable left channel zero cross interrupt flag */
;;;1299       if((u32Mask & SPII2S_LEFT_ZC_INT_MASK) == SPII2S_LEFT_ZC_INT_MASK)
000048  0649              LSLS     r1,r1,#25
00004a  d503              BPL      |L4.84|
;;;1300       {
;;;1301           i2s->I2SCTL |= SPI_I2SCTL_LZCIEN_Msk;
00004c  6e01              LDR      r1,[r0,#0x60]
00004e  f0417100          ORR      r1,r1,#0x2000000
000052  6601              STR      r1,[r0,#0x60]
                  |L4.84|
;;;1302       }
;;;1303   }
000054  4770              BX       lr
;;;1304   
                          ENDP


                          AREA ||i.SPII2S_EnableMCLK||, CODE, READONLY, ALIGN=1

                  SPII2S_EnableMCLK PROC
;;;1372     */
;;;1373   uint32_t SPII2S_EnableMCLK(SPI_T *i2s, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;1374   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1375       uint32_t u32Divider;
;;;1376       uint32_t u32SrcClk, u32RetValue;
;;;1377   
;;;1378       u32SrcClk = SPII2S_GetSourceClockFreq(i2s);
000006  f7fffffe          BL       SPII2S_GetSourceClockFreq
;;;1379       if(u32BusClock == u32SrcClk)
00000a  4285              CMP      r5,r0
00000c  d101              BNE      |L5.18|
;;;1380       {
;;;1381           u32Divider = 0U;
00000e  2100              MOVS     r1,#0
000010  e005              B        |L5.30|
                  |L5.18|
;;;1382       }
;;;1383       else
;;;1384       {
;;;1385           u32Divider = (u32SrcClk / u32BusClock) >> 1U;
000012  fbb0f1f5          UDIV     r1,r0,r5
000016  0849              LSRS     r1,r1,#1
;;;1386           /* MCLKDIV is a 6-bit width configuration. The maximum value is 0x3F. */
;;;1387           if(u32Divider > 0x3FU)
000018  293f              CMP      r1,#0x3f
00001a  d900              BLS      |L5.30|
;;;1388           {
;;;1389               u32Divider = 0x3FU;
00001c  213f              MOVS     r1,#0x3f
                  |L5.30|
;;;1390           }
;;;1391       }
;;;1392   
;;;1393       /* Write u32Divider to MCLKDIV (SPI_I2SCLK[5:0]) */
;;;1394       i2s->I2SCLK = (i2s->I2SCLK & ~SPI_I2SCLK_MCLKDIV_Msk) | (u32Divider << SPI_I2SCLK_MCLKDIV_Pos);
00001e  6e62              LDR      r2,[r4,#0x64]
000020  f022027f          BIC      r2,r2,#0x7f
000024  430a              ORRS     r2,r2,r1
000026  6662              STR      r2,[r4,#0x64]
;;;1395   
;;;1396       /* Enable MCLK output */
;;;1397       i2s->I2SCTL |= SPI_I2SCTL_MCLKEN_Msk;
000028  6e22              LDR      r2,[r4,#0x60]
00002a  f4424200          ORR      r2,r2,#0x8000
00002e  6622              STR      r2,[r4,#0x60]
;;;1398   
;;;1399       if(u32Divider == 0U)
000030  2900              CMP      r1,#0
000032  d002              BEQ      |L5.58|
;;;1400       {
;;;1401           u32RetValue = u32SrcClk; /* If MCLKDIV=0, master clock rate is equal to the source clock rate. */
;;;1402       }
;;;1403       else
;;;1404       {
;;;1405           u32RetValue = ((u32SrcClk >> 1U) / u32Divider); /* If MCLKDIV>0, master clock rate = source clock rate / (MCLKDIV * 2) */
000034  0840              LSRS     r0,r0,#1
000036  fbb0f0f1          UDIV     r0,r0,r1
                  |L5.58|
;;;1406       }
;;;1407   
;;;1408       return u32RetValue;
;;;1409   }
00003a  bd70              POP      {r4-r6,pc}
;;;1410   
                          ENDP


                          AREA ||i.SPII2S_GetSourceClockFreq||, CODE, READONLY, ALIGN=2

                  SPII2S_GetSourceClockFreq PROC
;;;1018     */
;;;1019   static uint32_t SPII2S_GetSourceClockFreq(SPI_T *i2s)
000000  4b29              LDR      r3,|L6.168|
;;;1020   {
;;;1021       uint32_t u32Freq;
;;;1022   
;;;1023       if(i2s == SPI0)
;;;1024       {
;;;1025           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;1026           {
;;;1027               u32Freq = __HXT; /* Clock source is HXT */
000002  492a              LDR      r1,|L6.172|
000004  049a              LSLS     r2,r3,#18             ;1025
000006  4298              CMP      r0,r3                 ;1023
000008  d111              BNE      |L6.46|
00000a  f8d20218          LDR      r0,[r2,#0x218]        ;1025
00000e  f0100f30          TST      r0,#0x30              ;1025
000012  d00a              BEQ      |L6.42|
;;;1028           }
;;;1029           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
000014  f8d20218          LDR      r0,[r2,#0x218]
000018  f3c01001          UBFX     r0,r0,#4,#2
00001c  2801              CMP      r0,#1
00001e  d040              BEQ      |L6.162|
;;;1030           {
;;;1031               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1032           }
;;;1033           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
000020  f8d20218          LDR      r0,[r2,#0x218]
000024  f3c01001          UBFX     r0,r0,#4,#2
000028  e026              B        |L6.120|
                  |L6.42|
00002a  4608              MOV      r0,r1                 ;1027
;;;1034           {
;;;1035               /* Clock source is PCLK1 */
;;;1036               u32Freq = CLK_GetPCLK1Freq();
;;;1037           }
;;;1038           else
;;;1039           {
;;;1040               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1041           }
;;;1042       }
;;;1043       else if(i2s == SPI1)
;;;1044       {
;;;1045           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
;;;1046           {
;;;1047               u32Freq = __HXT; /* Clock source is HXT */
;;;1048           }
;;;1049           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
;;;1050           {
;;;1051               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1052           }
;;;1053           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
;;;1054           {
;;;1055               /* Clock source is PCLK0 */
;;;1056               u32Freq = CLK_GetPCLK0Freq();
;;;1057           }
;;;1058           else
;;;1059           {
;;;1060               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1061           }
;;;1062       }
;;;1063       else if(i2s == SPI2)
;;;1064       {
;;;1065           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;1066           {
;;;1067               u32Freq = __HXT; /* Clock source is HXT */
;;;1068           }
;;;1069           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;1070           {
;;;1071               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1072           }
;;;1073           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;1074           {
;;;1075               /* Clock source is PCLK1 */
;;;1076               u32Freq = CLK_GetPCLK1Freq();
;;;1077           }
;;;1078           else
;;;1079           {
;;;1080               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1081           }
;;;1082       }
;;;1083       else
;;;1084       {
;;;1085           if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
;;;1086           {
;;;1087               u32Freq = __HXT; /* Clock source is HXT */
;;;1088           }
;;;1089           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
;;;1090           {
;;;1091               u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;1092           }
;;;1093           else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
;;;1094           {
;;;1095               /* Clock source is PCLK0 */
;;;1096               u32Freq = CLK_GetPCLK0Freq();
;;;1097           }
;;;1098           else
;;;1099           {
;;;1100               u32Freq = __HIRC; /* Clock source is HIRC */
;;;1101           }
;;;1102       }
;;;1103   
;;;1104       return u32Freq;
;;;1105   }
00002c  4770              BX       lr
                  |L6.46|
00002e  4b20              LDR      r3,|L6.176|
000030  4298              CMP      r0,r3                 ;1043
000032  d10f              BNE      |L6.84|
000034  f8d20218          LDR      r0,[r2,#0x218]        ;1045
000038  f0100fc0          TST      r0,#0xc0              ;1045
00003c  d0f5              BEQ      |L6.42|
00003e  f8d20218          LDR      r0,[r2,#0x218]        ;1049
000042  f3c01081          UBFX     r0,r0,#6,#2           ;1049
000046  2801              CMP      r0,#1                 ;1049
000048  d02b              BEQ      |L6.162|
00004a  f8d20218          LDR      r0,[r2,#0x218]        ;1053
00004e  f3c01081          UBFX     r0,r0,#6,#2           ;1053
000052  e022              B        |L6.154|
                  |L6.84|
000054  4b17              LDR      r3,|L6.180|
000056  4298              CMP      r0,r3                 ;1063
000058  f8d20218          LDR      r0,[r2,#0x218]        ;1085
00005c  d110              BNE      |L6.128|
00005e  f4106f40          TST      r0,#0xc00             ;1065
000062  d0e2              BEQ      |L6.42|
000064  f8d20218          LDR      r0,[r2,#0x218]        ;1069
000068  f3c02081          UBFX     r0,r0,#10,#2          ;1069
00006c  2801              CMP      r0,#1                 ;1069
00006e  d018              BEQ      |L6.162|
000070  f8d20218          LDR      r0,[r2,#0x218]        ;1073
000074  f3c02081          UBFX     r0,r0,#10,#2          ;1073
                  |L6.120|
000078  2802              CMP      r0,#2                 ;1073
00007a  d1d6              BNE      |L6.42|
00007c  f7ffbffe          B.W      CLK_GetPCLK1Freq
                  |L6.128|
000080  f4105f40          TST      r0,#0x3000            ;1085
000084  d0d1              BEQ      |L6.42|
000086  f8d20218          LDR      r0,[r2,#0x218]        ;1089
00008a  f3c03001          UBFX     r0,r0,#12,#2          ;1089
00008e  2801              CMP      r0,#1                 ;1089
000090  d007              BEQ      |L6.162|
000092  f8d20218          LDR      r0,[r2,#0x218]        ;1093
000096  f3c03001          UBFX     r0,r0,#12,#2          ;1093
                  |L6.154|
00009a  2802              CMP      r0,#2                 ;1093
00009c  d1c5              BNE      |L6.42|
00009e  f7ffbffe          B.W      CLK_GetPCLK0Freq
                  |L6.162|
0000a2  f7ffbffe          B.W      CLK_GetPLLClockFreq
;;;1106   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L6.168|
                          DCD      0x40061000
                  |L6.172|
                          DCD      0x00b71b00
                  |L6.176|
                          DCD      0x40062000
                  |L6.180|
                          DCD      0x40063000

                          AREA ||i.SPII2S_Open||, CODE, READONLY, ALIGN=2

                  SPII2S_Open PROC
;;;1132     */
;;;1133   uint32_t SPII2S_Open(SPI_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1134   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  e9dd100e          LDRD     r1,r0,[sp,#0x38]
;;;1135       uint32_t u32Divider;
;;;1136       uint32_t u32BitRate, u32SrcClk, u32RetValue;
;;;1137   
;;;1138       /* Reset SPI/I2S */
;;;1139       if(i2s == SPI0)
00000c  f8df912c          LDR      r9,|L7.316|
;;;1140       {
;;;1141           SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
;;;1142           SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
;;;1143       }
;;;1144       else if(i2s == SPI1)
000010  f8dfa12c          LDR      r10,|L7.320|
;;;1145       {
;;;1146           SYS->IPRST1 |= SYS_IPRST1_SPI1RST_Msk;
;;;1147           SYS->IPRST1 &= ~SYS_IPRST1_SPI1RST_Msk;
;;;1148       }
;;;1149       else if(i2s == SPI2)
000014  f8dfb12c          LDR      r11,|L7.324|
000018  461e              MOV      r6,r3                 ;1134
00001a  f04f4580          MOV      r5,#0x40000000        ;1141
00001e  454c              CMP      r4,r9                 ;1139
000020  d107              BNE      |L7.50|
000022  68ea              LDR      r2,[r5,#0xc]          ;1141
000024  f4425200          ORR      r2,r2,#0x2000         ;1141
000028  60ea              STR      r2,[r5,#0xc]          ;1141
00002a  68ea              LDR      r2,[r5,#0xc]          ;1142
00002c  f4225200          BIC      r2,r2,#0x2000         ;1142
000030  e012              B        |L7.88|
                  |L7.50|
000032  4554              CMP      r4,r10                ;1144
000034  d107              BNE      |L7.70|
000036  68ea              LDR      r2,[r5,#0xc]          ;1146
000038  f4424280          ORR      r2,r2,#0x4000         ;1146
00003c  60ea              STR      r2,[r5,#0xc]          ;1146
00003e  68ea              LDR      r2,[r5,#0xc]          ;1147
000040  f4224280          BIC      r2,r2,#0x4000         ;1147
000044  e008              B        |L7.88|
                  |L7.70|
000046  455c              CMP      r4,r11
000048  d108              BNE      |L7.92|
;;;1150       {
;;;1151           SYS->IPRST1 |= SYS_IPRST1_SPI2RST_Msk;
00004a  68ea              LDR      r2,[r5,#0xc]
00004c  f4424200          ORR      r2,r2,#0x8000
000050  60ea              STR      r2,[r5,#0xc]
;;;1152           SYS->IPRST1 &= ~SYS_IPRST1_SPI2RST_Msk;
000052  68ea              LDR      r2,[r5,#0xc]
000054  f4224200          BIC      r2,r2,#0x8000
                  |L7.88|
000058  60ea              STR      r2,[r5,#0xc]
00005a  e007              B        |L7.108|
                  |L7.92|
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           SYS->IPRST2 |= SYS_IPRST2_SPI3RST_Msk;
00005c  692a              LDR      r2,[r5,#0x10]
00005e  f0420240          ORR      r2,r2,#0x40
000062  612a              STR      r2,[r5,#0x10]
;;;1157           SYS->IPRST2 &= ~SYS_IPRST2_SPI3RST_Msk;
000064  692a              LDR      r2,[r5,#0x10]
000066  f0220240          BIC      r2,r2,#0x40
00006a  612a              STR      r2,[r5,#0x10]
                  |L7.108|
;;;1158       }
;;;1159   
;;;1160       /* Configure I2S controller */
;;;1161       i2s->I2SCTL = u32MasterSlave | u32WordWidth | u32Channels | u32DataFormat;
00006c  ea470206          ORR      r2,r7,r6
000070  430a              ORRS     r2,r2,r1
000072  4302              ORRS     r2,r2,r0
000074  6622              STR      r2,[r4,#0x60]
;;;1162       /* Set TX FIFO threshold to 2 and RX FIFO threshold to 1 */
;;;1163       SPI_SetFIFO(i2s, 2, 1);
000076  2201              MOVS     r2,#1
000078  2102              MOVS     r1,#2
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       SPI_SetFIFO
;;;1164   
;;;1165       if(u32MasterSlave == SPI_MASTER)
;;;1166       {
;;;1167           /* Get the source clock rate */
;;;1168           u32SrcClk = SPII2S_GetSourceClockFreq(i2s);
;;;1169   
;;;1170           /* Calculate the bit clock rate */
;;;1171           u32BitRate = u32SampleRate * ((u32WordWidth >> SPI_I2SCTL_WDWIDTH_Pos) + 1U) * 16U;
;;;1172           u32Divider = ((u32SrcClk / u32BitRate) >> 1U) - 1U;
;;;1173           //u32Divider = ((((u32SrcClk * 10UL / u32BitRate) >> 1U) + 5UL) / 10UL) - 1U;
;;;1174           /* Set BCLKDIV setting */
;;;1175           i2s->I2SCLK = (i2s->I2SCLK & ~SPI_I2SCLK_BCLKDIV_Msk) | (u32Divider << SPI_I2SCLK_BCLKDIV_Pos);
000080  f8df80c4          LDR      r8,|L7.328|
000084  b167              CBZ      r7,|L7.160|
;;;1176   
;;;1177           /* Calculate bit clock rate */
;;;1178           u32BitRate = u32SrcClk / ((u32Divider + 1U) * 2U);
;;;1179           /* Calculate real sample rate */
;;;1180           u32SampleRate = u32BitRate / (((u32WordWidth >> SPI_I2SCTL_WDWIDTH_Pos) + 1U) * 16U);
;;;1181   
;;;1182           /* Enable TX function, RX function and I2S mode. */
;;;1183           i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1184   
;;;1185           /* Return the real sample rate */
;;;1186           u32RetValue = u32SampleRate;
;;;1187       }
;;;1188       else
;;;1189       {
;;;1190           /* Set BCLKDIV = 0 */
;;;1191           i2s->I2SCLK &= ~SPI_I2SCLK_BCLKDIV_Msk;
000086  6e60              LDR      r0,[r4,#0x64]
000088  ea000008          AND      r0,r0,r8
00008c  6660              STR      r0,[r4,#0x64]
;;;1192   
;;;1193           if(i2s == SPI0)
00008e  454c              CMP      r4,r9
000090  d12b              BNE      |L7.234|
;;;1194           {
;;;1195               /* Set the peripheral clock rate to equal APB clock rate */
;;;1196               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
000092  f8d50218          LDR      r0,[r5,#0x218]
000096  f0200030          BIC      r0,r0,#0x30
00009a  f0400020          ORR      r0,r0,#0x20
;;;1197               /* Enable TX function, RX function and I2S mode. */
;;;1198               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1199               /* Return slave peripheral clock rate */
;;;1200               u32RetValue = CLK_GetPCLK1Freq();
00009e  e035              B        |L7.268|
                  |L7.160|
0000a0  4620              MOV      r0,r4                 ;1168
0000a2  f7fffffe          BL       SPII2S_GetSourceClockFreq
0000a6  2101              MOVS     r1,#1                 ;1171
0000a8  9a02              LDR      r2,[sp,#8]            ;1171
0000aa  eb011116          ADD      r1,r1,r6,LSR #4       ;1171
0000ae  4351              MULS     r1,r2,r1              ;1171
0000b0  0109              LSLS     r1,r1,#4              ;1171
0000b2  fbb0f1f1          UDIV     r1,r0,r1              ;1172
0000b6  f04f32ff          MOV      r2,#0xffffffff        ;1172
0000ba  eb020151          ADD      r1,r2,r1,LSR #1       ;1172
0000be  6e62              LDR      r2,[r4,#0x64]         ;1175
0000c0  ea020208          AND      r2,r2,r8              ;1175
0000c4  ea422201          ORR      r2,r2,r1,LSL #8       ;1175
0000c8  6662              STR      r2,[r4,#0x64]         ;1175
0000ca  0049              LSLS     r1,r1,#1              ;1178
0000cc  1c89              ADDS     r1,r1,#2              ;1178
0000ce  fbb0f0f1          UDIV     r0,r0,r1              ;1178
0000d2  0931              LSRS     r1,r6,#4              ;1180
0000d4  0109              LSLS     r1,r1,#4              ;1180
0000d6  3110              ADDS     r1,r1,#0x10           ;1180
0000d8  fbb0f0f1          UDIV     r0,r0,r1              ;1180
0000dc  6e21              LDR      r1,[r4,#0x60]         ;1183
0000de  f0410107          ORR      r1,r1,#7              ;1183
0000e2  6621              STR      r1,[r4,#0x60]         ;1183
;;;1201           }
;;;1202           else if(i2s == SPI1)
;;;1203           {
;;;1204               /* Set the peripheral clock rate to equal APB clock rate */
;;;1205               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;1206               /* Enable TX function, RX function and I2S mode. */
;;;1207               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1208               /* Return slave peripheral clock rate */
;;;1209               u32RetValue = CLK_GetPCLK0Freq();
;;;1210           }
;;;1211           else if(i2s == SPI2)
;;;1212           {
;;;1213               /* Set the peripheral clock rate to equal APB clock rate */
;;;1214               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;1215               /* Enable TX function, RX function and I2S mode. */
;;;1216               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1217               /* Return slave peripheral clock rate */
;;;1218               u32RetValue = CLK_GetPCLK1Freq();
;;;1219           }
;;;1220           else
;;;1221           {
;;;1222               /* Set the peripheral clock rate to equal APB clock rate */
;;;1223               CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
;;;1224               /* Enable TX function, RX function and I2S mode. */
;;;1225               i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;1226               /* Return slave peripheral clock rate */
;;;1227               u32RetValue = CLK_GetPCLK0Freq();
;;;1228           }
;;;1229       }
;;;1230   
;;;1231       return u32RetValue;
;;;1232   }
0000e4  b004              ADD      sp,sp,#0x10
0000e6  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.234|
0000ea  4554              CMP      r4,r10                ;1202
0000ec  d106              BNE      |L7.252|
0000ee  f8d50218          LDR      r0,[r5,#0x218]        ;1205
0000f2  f02000c0          BIC      r0,r0,#0xc0           ;1205
0000f6  f0400080          ORR      r0,r0,#0x80           ;1205
0000fa  e015              B        |L7.296|
                  |L7.252|
0000fc  f8d50218          LDR      r0,[r5,#0x218]        ;1223
000100  455c              CMP      r4,r11                ;1211
000102  d10d              BNE      |L7.288|
000104  f4206040          BIC      r0,r0,#0xc00          ;1214
000108  f4406000          ORR      r0,r0,#0x800          ;1214
                  |L7.268|
00010c  f8c50218          STR      r0,[r5,#0x218]        ;1214
000110  6e20              LDR      r0,[r4,#0x60]         ;1216
000112  f0400007          ORR      r0,r0,#7              ;1216
000116  6620              STR      r0,[r4,#0x60]         ;1216
000118  e8bd5fff          POP      {r0-r12,lr}           ;1218
00011c  f7ffbffe          B.W      CLK_GetPCLK1Freq
                  |L7.288|
000120  f4205040          BIC      r0,r0,#0x3000         ;1223
000124  f4405000          ORR      r0,r0,#0x2000         ;1223
                  |L7.296|
000128  f8c50218          STR      r0,[r5,#0x218]        ;1223
00012c  6e20              LDR      r0,[r4,#0x60]         ;1225
00012e  f0400007          ORR      r0,r0,#7              ;1225
000132  6620              STR      r0,[r4,#0x60]         ;1225
000134  e8bd5fff          POP      {r0-r12,lr}           ;1227
000138  f7ffbffe          B.W      CLK_GetPCLK0Freq
;;;1233   
                          ENDP

                  |L7.316|
                          DCD      0x40061000
                  |L7.320|
                          DCD      0x40062000
                  |L7.324|
                          DCD      0x40063000
                  |L7.328|
                          DCD      0xfffc00ff

                          AREA ||i.SPII2S_SetFIFO||, CODE, READONLY, ALIGN=1

                  SPII2S_SetFIFO PROC
;;;1429     */
;;;1430   void SPII2S_SetFIFO(SPI_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  6903              LDR      r3,[r0,#0x10]
;;;1431   {
;;;1432       i2s->FIFOCTL = (i2s->FIFOCTL & ~(SPI_FIFOCTL_TXTH_Msk | SPI_FIFOCTL_RXTH_Msk)) |
000002  f02343ee          BIC      r3,r3,#0x77000000
000006  ea437101          ORR      r1,r3,r1,LSL #28
00000a  ea416102          ORR      r1,r1,r2,LSL #24
00000e  6101              STR      r1,[r0,#0x10]
;;;1433                      (u32TxThreshold << SPI_FIFOCTL_TXTH_Pos) |
;;;1434                      (u32RxThreshold << SPI_FIFOCTL_RXTH_Pos);
;;;1435   }
000010  4770              BX       lr
;;;1436   
                          ENDP


                          AREA ||i.SPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearIntFlag PROC
;;;887      */
;;;888    void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;889    {
000002  d001              BEQ      |L9.8|
;;;890        if(u32Mask & SPI_UNIT_INT_MASK)
;;;891        {
;;;892            spi->STATUS = SPI_STATUS_UNITIF_Msk; /* Clear unit transfer interrupt flag */
000004  2202              MOVS     r2,#2
000006  6142              STR      r2,[r0,#0x14]
                  |L9.8|
;;;893        }
;;;894    
;;;895        if(u32Mask & SPI_SSACT_INT_MASK)
000008  078a              LSLS     r2,r1,#30
00000a  d501              BPL      |L9.16|
;;;896        {
;;;897            spi->STATUS = SPI_STATUS_SSACTIF_Msk; /* Clear slave selection signal active interrupt flag */
00000c  2204              MOVS     r2,#4
00000e  6142              STR      r2,[r0,#0x14]
                  |L9.16|
;;;898        }
;;;899    
;;;900        if(u32Mask & SPI_SSINACT_INT_MASK)
000010  074a              LSLS     r2,r1,#29
000012  d501              BPL      |L9.24|
;;;901        {
;;;902            spi->STATUS = SPI_STATUS_SSINAIF_Msk; /* Clear slave selection signal inactive interrupt flag */
000014  2208              MOVS     r2,#8
000016  6142              STR      r2,[r0,#0x14]
                  |L9.24|
;;;903        }
;;;904    
;;;905        if(u32Mask & SPI_SLVUR_INT_MASK)
000018  070a              LSLS     r2,r1,#28
00001a  d501              BPL      |L9.32|
;;;906        {
;;;907            spi->STATUS = SPI_STATUS_SLVURIF_Msk; /* Clear slave TX under run interrupt flag */
00001c  2280              MOVS     r2,#0x80
00001e  6142              STR      r2,[r0,#0x14]
                  |L9.32|
;;;908        }
;;;909    
;;;910        if(u32Mask & SPI_SLVBE_INT_MASK)
000020  06ca              LSLS     r2,r1,#27
000022  d501              BPL      |L9.40|
;;;911        {
;;;912            spi->STATUS = SPI_STATUS_SLVBEIF_Msk; /* Clear slave bit count error interrupt flag */
000024  2240              MOVS     r2,#0x40
000026  6142              STR      r2,[r0,#0x14]
                  |L9.40|
;;;913        }
;;;914    
;;;915        if(u32Mask & SPI_TXUF_INT_MASK)
000028  064a              LSLS     r2,r1,#25
00002a  d502              BPL      |L9.50|
;;;916        {
;;;917            spi->STATUS = SPI_STATUS_TXUFIF_Msk; /* Clear slave TX underflow interrupt flag */
00002c  f44f2200          MOV      r2,#0x80000
000030  6142              STR      r2,[r0,#0x14]
                  |L9.50|
;;;918        }
;;;919    
;;;920        if(u32Mask & SPI_FIFO_RXOV_INT_MASK)
000032  058a              LSLS     r2,r1,#22
000034  d502              BPL      |L9.60|
;;;921        {
;;;922            spi->STATUS = SPI_STATUS_RXOVIF_Msk; /* Clear RX overrun interrupt flag */
000036  f44f6200          MOV      r2,#0x800
00003a  6142              STR      r2,[r0,#0x14]
                  |L9.60|
;;;923        }
;;;924    
;;;925        if(u32Mask & SPI_FIFO_RXTO_INT_MASK)
00003c  0549              LSLS     r1,r1,#21
00003e  d502              BPL      |L9.70|
;;;926        {
;;;927            spi->STATUS = SPI_STATUS_RXTOIF_Msk; /* Clear RX time-out interrupt flag */
000040  f44f5180          MOV      r1,#0x1000
000044  6141              STR      r1,[r0,#0x14]
                  |L9.70|
;;;928        }
;;;929    }
000046  4770              BX       lr
;;;930    
                          ENDP


                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;292      */
;;;293    void SPI_ClearRxFIFO(SPI_T *spi)
000000  6901              LDR      r1,[r0,#0x10]
;;;294    {
;;;295        spi->FIFOCTL |= SPI_FIFOCTL_RXFBCLR_Msk;
000002  f4417180          ORR      r1,r1,#0x100
000006  6101              STR      r1,[r0,#0x10]
;;;296    }
000008  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;304      */
;;;305    void SPI_ClearTxFIFO(SPI_T *spi)
000000  6901              LDR      r1,[r0,#0x10]
;;;306    {
;;;307        spi->FIFOCTL |= SPI_FIFOCTL_TXFBCLR_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;308    }
000008  4770              BX       lr
;;;309    
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;258      */
;;;259    void SPI_Close(SPI_T *spi)
000000  4a15              LDR      r2,|L12.88|
;;;260    {
;;;261        if(spi == SPI0)
;;;262        {
;;;263            /* Reset SPI */
;;;264            SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
000002  0491              LSLS     r1,r2,#18
000004  4290              CMP      r0,r2                 ;261
000006  d107              BNE      |L12.24|
000008  68c8              LDR      r0,[r1,#0xc]
00000a  f4405000          ORR      r0,r0,#0x2000
00000e  60c8              STR      r0,[r1,#0xc]
;;;265            SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
000010  68c8              LDR      r0,[r1,#0xc]
000012  f4205000          BIC      r0,r0,#0x2000
000016  e009              B        |L12.44|
                  |L12.24|
;;;266        }
;;;267        else if(spi == SPI1)
000018  4a10              LDR      r2,|L12.92|
00001a  4290              CMP      r0,r2
00001c  d108              BNE      |L12.48|
;;;268        {
;;;269            /* Reset SPI */
;;;270            SYS->IPRST1 |= SYS_IPRST1_SPI1RST_Msk;
00001e  68c8              LDR      r0,[r1,#0xc]
000020  f4404080          ORR      r0,r0,#0x4000
000024  60c8              STR      r0,[r1,#0xc]
;;;271            SYS->IPRST1 &= ~SYS_IPRST1_SPI1RST_Msk;
000026  68c8              LDR      r0,[r1,#0xc]
000028  f4204080          BIC      r0,r0,#0x4000
                  |L12.44|
00002c  60c8              STR      r0,[r1,#0xc]          ;265
;;;272        }
;;;273        else if(spi == SPI2)
;;;274        {
;;;275            /* Reset SPI */
;;;276            SYS->IPRST1 |= SYS_IPRST1_SPI2RST_Msk;
;;;277            SYS->IPRST1 &= ~SYS_IPRST1_SPI2RST_Msk;
;;;278        }
;;;279        else
;;;280        {
;;;281            /* Reset SPI */
;;;282            SYS->IPRST2 |= SYS_IPRST2_SPI3RST_Msk;
;;;283            SYS->IPRST2 &= ~SYS_IPRST2_SPI3RST_Msk;
;;;284        }
;;;285    }
00002e  4770              BX       lr
                  |L12.48|
000030  4a0b              LDR      r2,|L12.96|
000032  4290              CMP      r0,r2                 ;273
000034  d107              BNE      |L12.70|
000036  68c8              LDR      r0,[r1,#0xc]          ;276
000038  f4404000          ORR      r0,r0,#0x8000         ;276
00003c  60c8              STR      r0,[r1,#0xc]          ;276
00003e  68c8              LDR      r0,[r1,#0xc]          ;277
000040  f4204000          BIC      r0,r0,#0x8000         ;277
000044  e7f2              B        |L12.44|
                  |L12.70|
000046  6908              LDR      r0,[r1,#0x10]         ;282
000048  f0400040          ORR      r0,r0,#0x40           ;282
00004c  6108              STR      r0,[r1,#0x10]         ;282
00004e  6908              LDR      r0,[r1,#0x10]         ;283
000050  f0200040          BIC      r0,r0,#0x40           ;283
000054  6108              STR      r0,[r1,#0x10]         ;283
000056  4770              BX       lr
;;;286    
                          ENDP

                  |L12.88|
                          DCD      0x40061000
                  |L12.92|
                          DCD      0x40062000
                  |L12.96|
                          DCD      0x40063000

                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;315      */
;;;316    void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;317    {
;;;318        spi->SSCTL &= ~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SS_Msk);
000002  f0210109          BIC      r1,r1,#9
000006  6081              STR      r1,[r0,#8]
;;;319    }
000008  4770              BX       lr
;;;320    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;709      */
;;;710    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;711    {
000002  d003              BEQ      |L14.12|
;;;712        /* Disable unit transfer interrupt flag */
;;;713        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;714        {
;;;715            spi->CTL &= ~SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4223200          BIC      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L14.12|
;;;716        }
;;;717    
;;;718        /* Disable slave selection signal active interrupt flag */
;;;719        if((u32Mask & SPI_SSACT_INT_MASK) == SPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L14.24|
;;;720        {
;;;721            spi->SSCTL &= ~SPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4225280          BIC      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L14.24|
;;;722        }
;;;723    
;;;724        /* Disable slave selection signal inactive interrupt flag */
;;;725        if((u32Mask & SPI_SSINACT_INT_MASK) == SPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L14.36|
;;;726        {
;;;727            spi->SSCTL &= ~SPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4225200          BIC      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L14.36|
;;;728        }
;;;729    
;;;730        /* Disable slave TX under run interrupt flag */
;;;731        if((u32Mask & SPI_SLVUR_INT_MASK) == SPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L14.48|
;;;732        {
;;;733            spi->SSCTL &= ~SPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4227200          BIC      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L14.48|
;;;734        }
;;;735    
;;;736        /* Disable slave bit count error interrupt flag */
;;;737        if((u32Mask & SPI_SLVBE_INT_MASK) == SPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L14.60|
;;;738        {
;;;739            spi->SSCTL &= ~SPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4227280          BIC      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L14.60|
;;;740        }
;;;741    
;;;742        /* Disable slave TX underflow interrupt flag */
;;;743        if((u32Mask & SPI_TXUF_INT_MASK) == SPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L14.72|
;;;744        {
;;;745            spi->FIFOCTL &= ~SPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0220280          BIC      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L14.72|
;;;746        }
;;;747    
;;;748        /* Disable TX threshold interrupt flag */
;;;749        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) == SPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L14.84|
;;;750        {
;;;751            spi->FIFOCTL &= ~SPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0220208          BIC      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L14.84|
;;;752        }
;;;753    
;;;754        /* Disable RX threshold interrupt flag */
;;;755        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) == SPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L14.96|
;;;756        {
;;;757            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0220204          BIC      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L14.96|
;;;758        }
;;;759    
;;;760        /* Disable RX overrun interrupt flag */
;;;761        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L14.108|
;;;762        {
;;;763            spi->FIFOCTL &= ~SPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0220220          BIC      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L14.108|
;;;764        }
;;;765    
;;;766        /* Disable RX time-out interrupt flag */
;;;767        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) == SPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L14.120|
;;;768        {
;;;769            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0210110          BIC      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L14.120|
;;;770        }
;;;771    }
000078  4770              BX       lr
;;;772    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;329      */
;;;330    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  6883              LDR      r3,[r0,#8]
;;;331    {
;;;332        spi->SSCTL = (spi->SSCTL & (~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SSACTPOL_Msk | SPI_SSCTL_SS_Msk))) | (u32SSPinMask | u32ActiveLevel | SPI_SSCTL_AUTOSS_Msk);
000002  4311              ORRS     r1,r1,r2
000004  f023030d          BIC      r3,r3,#0xd
000008  430b              ORRS     r3,r3,r1
00000a  f0430108          ORR      r1,r3,#8
00000e  6081              STR      r1,[r0,#8]
;;;333    }
000010  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;626      */
;;;627    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;628    {
000002  d003              BEQ      |L16.12|
;;;629        /* Enable unit transfer interrupt flag */
;;;630        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;631        {
;;;632            spi->CTL |= SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  f4423200          ORR      r2,r2,#0x20000
00000a  6002              STR      r2,[r0,#0]
                  |L16.12|
;;;633        }
;;;634    
;;;635        /* Enable slave selection signal active interrupt flag */
;;;636        if((u32Mask & SPI_SSACT_INT_MASK) == SPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L16.24|
;;;637        {
;;;638            spi->SSCTL |= SPI_SSCTL_SSACTIEN_Msk;
000010  6882              LDR      r2,[r0,#8]
000012  f4425280          ORR      r2,r2,#0x1000
000016  6082              STR      r2,[r0,#8]
                  |L16.24|
;;;639        }
;;;640    
;;;641        /* Enable slave selection signal inactive interrupt flag */
;;;642        if((u32Mask & SPI_SSINACT_INT_MASK) == SPI_SSINACT_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L16.36|
;;;643        {
;;;644            spi->SSCTL |= SPI_SSCTL_SSINAIEN_Msk;
00001c  6882              LDR      r2,[r0,#8]
00001e  f4425200          ORR      r2,r2,#0x2000
000022  6082              STR      r2,[r0,#8]
                  |L16.36|
;;;645        }
;;;646    
;;;647        /* Enable slave TX under run interrupt flag */
;;;648        if((u32Mask & SPI_SLVUR_INT_MASK) == SPI_SLVUR_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L16.48|
;;;649        {
;;;650            spi->SSCTL |= SPI_SSCTL_SLVURIEN_Msk;
000028  6882              LDR      r2,[r0,#8]
00002a  f4427200          ORR      r2,r2,#0x200
00002e  6082              STR      r2,[r0,#8]
                  |L16.48|
;;;651        }
;;;652    
;;;653        /* Enable slave bit count error interrupt flag */
;;;654        if((u32Mask & SPI_SLVBE_INT_MASK) == SPI_SLVBE_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L16.60|
;;;655        {
;;;656            spi->SSCTL |= SPI_SSCTL_SLVBEIEN_Msk;
000034  6882              LDR      r2,[r0,#8]
000036  f4427280          ORR      r2,r2,#0x100
00003a  6082              STR      r2,[r0,#8]
                  |L16.60|
;;;657        }
;;;658    
;;;659        /* Enable slave TX underflow interrupt flag */
;;;660        if((u32Mask & SPI_TXUF_INT_MASK) == SPI_TXUF_INT_MASK)
00003c  064a              LSLS     r2,r1,#25
00003e  d503              BPL      |L16.72|
;;;661        {
;;;662            spi->FIFOCTL |= SPI_FIFOCTL_TXUFIEN_Msk;
000040  6902              LDR      r2,[r0,#0x10]
000042  f0420280          ORR      r2,r2,#0x80
000046  6102              STR      r2,[r0,#0x10]
                  |L16.72|
;;;663        }
;;;664    
;;;665        /* Enable TX threshold interrupt flag */
;;;666        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) == SPI_FIFO_TXTH_INT_MASK)
000048  060a              LSLS     r2,r1,#24
00004a  d503              BPL      |L16.84|
;;;667        {
;;;668            spi->FIFOCTL |= SPI_FIFOCTL_TXTHIEN_Msk;
00004c  6902              LDR      r2,[r0,#0x10]
00004e  f0420208          ORR      r2,r2,#8
000052  6102              STR      r2,[r0,#0x10]
                  |L16.84|
;;;669        }
;;;670    
;;;671        /* Enable RX threshold interrupt flag */
;;;672        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) == SPI_FIFO_RXTH_INT_MASK)
000054  05ca              LSLS     r2,r1,#23
000056  d503              BPL      |L16.96|
;;;673        {
;;;674            spi->FIFOCTL |= SPI_FIFOCTL_RXTHIEN_Msk;
000058  6902              LDR      r2,[r0,#0x10]
00005a  f0420204          ORR      r2,r2,#4
00005e  6102              STR      r2,[r0,#0x10]
                  |L16.96|
;;;675        }
;;;676    
;;;677        /* Enable RX overrun interrupt flag */
;;;678        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000060  058a              LSLS     r2,r1,#22
000062  d503              BPL      |L16.108|
;;;679        {
;;;680            spi->FIFOCTL |= SPI_FIFOCTL_RXOVIEN_Msk;
000064  6902              LDR      r2,[r0,#0x10]
000066  f0420220          ORR      r2,r2,#0x20
00006a  6102              STR      r2,[r0,#0x10]
                  |L16.108|
;;;681        }
;;;682    
;;;683        /* Enable RX time-out interrupt flag */
;;;684        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) == SPI_FIFO_RXTO_INT_MASK)
00006c  0549              LSLS     r1,r1,#21
00006e  d503              BPL      |L16.120|
;;;685        {
;;;686            spi->FIFOCTL |= SPI_FIFOCTL_RXTOIEN_Msk;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0410110          ORR      r1,r1,#0x10
000076  6101              STR      r1,[r0,#0x10]
                  |L16.120|
;;;687        }
;;;688    }
000078  4770              BX       lr
;;;689    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;512      */
;;;513    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b510              PUSH     {r4,lr}
;;;514    {
;;;515        uint32_t u32Div;
;;;516        uint32_t u32ClkSrc;
;;;517    
;;;518        /* Get DIVIDER setting */
;;;519        u32Div = (spi->CLKDIV & SPI_CLKDIV_DIVIDER_Msk) >> SPI_CLKDIV_DIVIDER_Pos;
000002  6841              LDR      r1,[r0,#4]
;;;520    
;;;521        /* Check clock source of SPI */
;;;522        if(spi == SPI0)
000004  4b2d              LDR      r3,|L17.188|
000006  f3c10408          UBFX     r4,r1,#0,#9           ;519
;;;523        {
;;;524            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;525            {
;;;526                u32ClkSrc = __HXT; /* Clock source is HXT */
00000a  492d              LDR      r1,|L17.192|
00000c  049a              LSLS     r2,r3,#18             ;524
00000e  4298              CMP      r0,r3                 ;522
000010  d10f              BNE      |L17.50|
000012  f8d20218          LDR      r0,[r2,#0x218]        ;524
000016  f0100f30          TST      r0,#0x30              ;524
00001a  d043              BEQ      |L17.164|
;;;527            }
;;;528            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
00001c  f8d20218          LDR      r0,[r2,#0x218]
000020  f3c01001          UBFX     r0,r0,#4,#2
000024  2801              CMP      r0,#1
000026  d042              BEQ      |L17.174|
;;;529            {
;;;530                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;531            }
;;;532            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
000028  f8d20218          LDR      r0,[r2,#0x218]
00002c  f3c01001          UBFX     r0,r0,#4,#2
000030  e024              B        |L17.124|
                  |L17.50|
;;;533            {
;;;534                /* Clock source is PCLK1 */
;;;535                u32ClkSrc = CLK_GetPCLK1Freq();
;;;536            }
;;;537            else
;;;538            {
;;;539                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;540            }
;;;541        }
;;;542        else if(spi == SPI1)
000032  4b24              LDR      r3,|L17.196|
000034  4298              CMP      r0,r3
000036  d10f              BNE      |L17.88|
;;;543        {
;;;544            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
000038  f8d20218          LDR      r0,[r2,#0x218]
00003c  f0100fc0          TST      r0,#0xc0
000040  d030              BEQ      |L17.164|
;;;545            {
;;;546                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;547            }
;;;548            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
000042  f8d20218          LDR      r0,[r2,#0x218]
000046  f3c01081          UBFX     r0,r0,#6,#2
00004a  2801              CMP      r0,#1
00004c  d02f              BEQ      |L17.174|
;;;549            {
;;;550                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;551            }
;;;552            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
00004e  f8d20218          LDR      r0,[r2,#0x218]
000052  f3c01081          UBFX     r0,r0,#6,#2
000056  e023              B        |L17.160|
                  |L17.88|
;;;553            {
;;;554                /* Clock source is PCLK0 */
;;;555                u32ClkSrc = CLK_GetPCLK0Freq();
;;;556            }
;;;557            else
;;;558            {
;;;559                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;560            }
;;;561        }
;;;562        else if(spi == SPI2)
000058  4b1b              LDR      r3,|L17.200|
00005a  4298              CMP      r0,r3
;;;563        {
;;;564            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;565            {
;;;566                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;567            }
;;;568            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;569            {
;;;570                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;571            }
;;;572            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;573            {
;;;574                /* Clock source is PCLK1 */
;;;575                u32ClkSrc = CLK_GetPCLK1Freq();
;;;576            }
;;;577            else
;;;578            {
;;;579                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;580            }
;;;581        }
;;;582        else
;;;583        {
;;;584            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
00005c  f8d20218          LDR      r0,[r2,#0x218]
000060  d111              BNE      |L17.134|
000062  f4106f40          TST      r0,#0xc00             ;564
000066  d01d              BEQ      |L17.164|
000068  f8d20218          LDR      r0,[r2,#0x218]        ;568
00006c  f3c02081          UBFX     r0,r0,#10,#2          ;568
000070  2801              CMP      r0,#1                 ;568
000072  d01c              BEQ      |L17.174|
000074  f8d20218          LDR      r0,[r2,#0x218]        ;572
000078  f3c02081          UBFX     r0,r0,#10,#2          ;572
                  |L17.124|
00007c  2802              CMP      r0,#2                 ;532
00007e  d111              BNE      |L17.164|
000080  f7fffffe          BL       CLK_GetPCLK1Freq
000084  e00f              B        |L17.166|
                  |L17.134|
000086  f4105f40          TST      r0,#0x3000
00008a  d00b              BEQ      |L17.164|
;;;585            {
;;;586                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;587            }
;;;588            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
00008c  f8d20218          LDR      r0,[r2,#0x218]
000090  f3c03001          UBFX     r0,r0,#12,#2
000094  2801              CMP      r0,#1
000096  d00a              BEQ      |L17.174|
;;;589            {
;;;590                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;591            }
;;;592            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
000098  f8d20218          LDR      r0,[r2,#0x218]
00009c  f3c03001          UBFX     r0,r0,#12,#2
                  |L17.160|
0000a0  2802              CMP      r0,#2                 ;552
0000a2  d007              BEQ      |L17.180|
                  |L17.164|
;;;593            {
;;;594                /* Clock source is PCLK0 */
;;;595                u32ClkSrc = CLK_GetPCLK0Freq();
;;;596            }
;;;597            else
;;;598            {
;;;599                u32ClkSrc = __HIRC; /* Clock source is HIRC */
0000a4  4608              MOV      r0,r1
                  |L17.166|
0000a6  1c64              ADDS     r4,r4,#1
;;;600            }
;;;601        }
;;;602    
;;;603        /* Return SPI bus clock rate */
;;;604        return (u32ClkSrc / (u32Div + 1U));
0000a8  fbb0f0f4          UDIV     r0,r0,r4
;;;605    }
0000ac  bd10              POP      {r4,pc}
                  |L17.174|
0000ae  f7fffffe          BL       CLK_GetPLLClockFreq
0000b2  e7f8              B        |L17.166|
                  |L17.180|
0000b4  f7fffffe          BL       CLK_GetPCLK0Freq
0000b8  e7f5              B        |L17.166|
;;;606    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L17.188|
                          DCD      0x40061000
                  |L17.192|
                          DCD      0x00b71b00
                  |L17.196|
                          DCD      0x40062000
                  |L17.200|
                          DCD      0x40063000

                          AREA ||i.SPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_GetIntFlag PROC
;;;792      */
;;;793    uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;794    {
000002  4602              MOV      r2,r0
;;;795        uint32_t u32IntFlag = 0U, u32TmpVal;
000004  2000              MOVS     r0,#0
;;;796    
;;;797        u32TmpVal = spi->STATUS & SPI_STATUS_UNITIF_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;798        /* Check unit transfer interrupt flag */
;;;799        if((u32Mask & SPI_UNIT_INT_MASK) && (u32TmpVal))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030302          AND      r3,r3,#2              ;797
00000e  d001              BEQ      |L18.20|
000010  b103              CBZ      r3,|L18.20|
;;;800        {
;;;801            u32IntFlag |= SPI_UNIT_INT_MASK;
000012  2001              MOVS     r0,#1
                  |L18.20|
;;;802        }
;;;803    
;;;804        u32TmpVal = spi->STATUS & SPI_STATUS_SSACTIF_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;805        /* Check slave selection signal active interrupt flag */
;;;806        if((u32Mask & SPI_SSACT_INT_MASK) && (u32TmpVal))
000016  078c              LSLS     r4,r1,#30
000018  f0030304          AND      r3,r3,#4              ;804
00001c  d502              BPL      |L18.36|
00001e  b10b              CBZ      r3,|L18.36|
;;;807        {
;;;808            u32IntFlag |= SPI_SSACT_INT_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L18.36|
;;;809        }
;;;810    
;;;811        u32TmpVal = spi->STATUS & SPI_STATUS_SSINAIF_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;812        /* Check slave selection signal inactive interrupt flag */
;;;813        if((u32Mask & SPI_SSINACT_INT_MASK) && (u32TmpVal))
000026  074c              LSLS     r4,r1,#29
000028  f0030308          AND      r3,r3,#8              ;811
00002c  d502              BPL      |L18.52|
00002e  b10b              CBZ      r3,|L18.52|
;;;814        {
;;;815            u32IntFlag |= SPI_SSINACT_INT_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L18.52|
;;;816        }
;;;817    
;;;818        u32TmpVal = spi->STATUS & SPI_STATUS_SLVURIF_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;819        /* Check slave TX under run interrupt flag */
;;;820        if((u32Mask & SPI_SLVUR_INT_MASK) && (u32TmpVal))
000036  070c              LSLS     r4,r1,#28
000038  f0030380          AND      r3,r3,#0x80           ;818
00003c  d502              BPL      |L18.68|
00003e  b10b              CBZ      r3,|L18.68|
;;;821        {
;;;822            u32IntFlag |= SPI_SLVUR_INT_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L18.68|
;;;823        }
;;;824    
;;;825        u32TmpVal = spi->STATUS & SPI_STATUS_SLVBEIF_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;826        /* Check slave bit count error interrupt flag */
;;;827        if((u32Mask & SPI_SLVBE_INT_MASK) && (u32TmpVal))
000046  06cc              LSLS     r4,r1,#27
000048  f0030340          AND      r3,r3,#0x40           ;825
00004c  d502              BPL      |L18.84|
00004e  b10b              CBZ      r3,|L18.84|
;;;828        {
;;;829            u32IntFlag |= SPI_SLVBE_INT_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L18.84|
;;;830        }
;;;831    
;;;832        u32TmpVal = spi->STATUS & SPI_STATUS_TXUFIF_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;833        /* Check slave TX underflow interrupt flag */
;;;834        if((u32Mask & SPI_TXUF_INT_MASK) && (u32TmpVal))
000056  064c              LSLS     r4,r1,#25
000058  f4032300          AND      r3,r3,#0x80000        ;832
00005c  d502              BPL      |L18.100|
00005e  b10b              CBZ      r3,|L18.100|
;;;835        {
;;;836            u32IntFlag |= SPI_TXUF_INT_MASK;
000060  f0400040          ORR      r0,r0,#0x40
                  |L18.100|
;;;837        }
;;;838    
;;;839        u32TmpVal = spi->STATUS & SPI_STATUS_TXTHIF_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;840        /* Check TX threshold interrupt flag */
;;;841        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) && (u32TmpVal))
000066  060c              LSLS     r4,r1,#24
000068  f4032380          AND      r3,r3,#0x40000        ;839
00006c  d502              BPL      |L18.116|
00006e  b10b              CBZ      r3,|L18.116|
;;;842        {
;;;843            u32IntFlag |= SPI_FIFO_TXTH_INT_MASK;
000070  f0400080          ORR      r0,r0,#0x80
                  |L18.116|
;;;844        }
;;;845    
;;;846        u32TmpVal = spi->STATUS & SPI_STATUS_RXTHIF_Msk;
000074  6953              LDR      r3,[r2,#0x14]
;;;847        /* Check RX threshold interrupt flag */
;;;848        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) && (u32TmpVal))
000076  05cc              LSLS     r4,r1,#23
000078  f4036380          AND      r3,r3,#0x400          ;846
00007c  d502              BPL      |L18.132|
00007e  b10b              CBZ      r3,|L18.132|
;;;849        {
;;;850            u32IntFlag |= SPI_FIFO_RXTH_INT_MASK;
000080  f4407080          ORR      r0,r0,#0x100
                  |L18.132|
;;;851        }
;;;852    
;;;853        u32TmpVal = spi->STATUS & SPI_STATUS_RXOVIF_Msk;
000084  6953              LDR      r3,[r2,#0x14]
;;;854        /* Check RX overrun interrupt flag */
;;;855        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) && (u32TmpVal))
000086  058c              LSLS     r4,r1,#22
000088  f4036300          AND      r3,r3,#0x800          ;853
00008c  d502              BPL      |L18.148|
00008e  b10b              CBZ      r3,|L18.148|
;;;856        {
;;;857            u32IntFlag |= SPI_FIFO_RXOV_INT_MASK;
000090  f4407000          ORR      r0,r0,#0x200
                  |L18.148|
;;;858        }
;;;859    
;;;860        u32TmpVal = spi->STATUS & SPI_STATUS_RXTOIF_Msk;
000094  6952              LDR      r2,[r2,#0x14]
;;;861        /* Check RX time-out interrupt flag */
;;;862        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) && (u32TmpVal))
000096  0549              LSLS     r1,r1,#21
000098  f4025280          AND      r2,r2,#0x1000         ;860
00009c  d503              BPL      |L18.166|
00009e  2a00              CMP      r2,#0
0000a0  d001              BEQ      |L18.166|
;;;863        {
;;;864            u32IntFlag |= SPI_FIFO_RXTO_INT_MASK;
0000a2  f4406080          ORR      r0,r0,#0x400
                  |L18.166|
;;;865        }
;;;866    
;;;867        return u32IntFlag;
;;;868    }
0000a6  bd10              POP      {r4,pc}
;;;869    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;948      */
;;;949    uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;950    {
000002  4602              MOV      r2,r0
;;;951        uint32_t u32Flag = 0U, u32TmpValue;
000004  2000              MOVS     r0,#0
;;;952    
;;;953        u32TmpValue = spi->STATUS & SPI_STATUS_BUSY_Msk;
000006  6953              LDR      r3,[r2,#0x14]
;;;954        /* Check busy status */
;;;955        if((u32Mask & SPI_BUSY_MASK) && (u32TmpValue))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030301          AND      r3,r3,#1              ;953
00000e  d001              BEQ      |L19.20|
000010  b103              CBZ      r3,|L19.20|
;;;956        {
;;;957            u32Flag |= SPI_BUSY_MASK;
000012  2001              MOVS     r0,#1
                  |L19.20|
;;;958        }
;;;959    
;;;960        u32TmpValue = spi->STATUS & SPI_STATUS_RXEMPTY_Msk;
000014  6953              LDR      r3,[r2,#0x14]
;;;961        /* Check RX empty flag */
;;;962        if((u32Mask & SPI_RX_EMPTY_MASK) && (u32TmpValue))
000016  078c              LSLS     r4,r1,#30
000018  f4037380          AND      r3,r3,#0x100          ;960
00001c  d502              BPL      |L19.36|
00001e  b10b              CBZ      r3,|L19.36|
;;;963        {
;;;964            u32Flag |= SPI_RX_EMPTY_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L19.36|
;;;965        }
;;;966    
;;;967        u32TmpValue = spi->STATUS & SPI_STATUS_RXFULL_Msk;
000024  6953              LDR      r3,[r2,#0x14]
;;;968        /* Check RX full flag */
;;;969        if((u32Mask & SPI_RX_FULL_MASK) && (u32TmpValue))
000026  074c              LSLS     r4,r1,#29
000028  f4037300          AND      r3,r3,#0x200          ;967
00002c  d502              BPL      |L19.52|
00002e  b10b              CBZ      r3,|L19.52|
;;;970        {
;;;971            u32Flag |= SPI_RX_FULL_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L19.52|
;;;972        }
;;;973    
;;;974        u32TmpValue = spi->STATUS & SPI_STATUS_TXEMPTY_Msk;
000034  6953              LDR      r3,[r2,#0x14]
;;;975        /* Check TX empty flag */
;;;976        if((u32Mask & SPI_TX_EMPTY_MASK) && (u32TmpValue))
000036  070c              LSLS     r4,r1,#28
000038  f4033380          AND      r3,r3,#0x10000        ;974
00003c  d502              BPL      |L19.68|
00003e  b10b              CBZ      r3,|L19.68|
;;;977        {
;;;978            u32Flag |= SPI_TX_EMPTY_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L19.68|
;;;979        }
;;;980    
;;;981        u32TmpValue = spi->STATUS & SPI_STATUS_TXFULL_Msk;
000044  6953              LDR      r3,[r2,#0x14]
;;;982        /* Check TX full flag */
;;;983        if((u32Mask & SPI_TX_FULL_MASK) && (u32TmpValue))
000046  06cc              LSLS     r4,r1,#27
000048  f4033300          AND      r3,r3,#0x20000        ;981
00004c  d502              BPL      |L19.84|
00004e  b10b              CBZ      r3,|L19.84|
;;;984        {
;;;985            u32Flag |= SPI_TX_FULL_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L19.84|
;;;986        }
;;;987    
;;;988        u32TmpValue = spi->STATUS & SPI_STATUS_TXRXRST_Msk;
000054  6953              LDR      r3,[r2,#0x14]
;;;989        /* Check TX/RX reset flag */
;;;990        if((u32Mask & SPI_TXRX_RESET_MASK) && (u32TmpValue))
000056  068c              LSLS     r4,r1,#26
000058  f4030300          AND      r3,r3,#0x800000       ;988
00005c  d502              BPL      |L19.100|
00005e  b10b              CBZ      r3,|L19.100|
;;;991        {
;;;992            u32Flag |= SPI_TXRX_RESET_MASK;
000060  f0400020          ORR      r0,r0,#0x20
                  |L19.100|
;;;993        }
;;;994    
;;;995        u32TmpValue = spi->STATUS & SPI_STATUS_SPIENSTS_Msk;
000064  6953              LDR      r3,[r2,#0x14]
;;;996        /* Check SPIEN flag */
;;;997        if((u32Mask & SPI_SPIEN_STS_MASK) && (u32TmpValue))
000066  064c              LSLS     r4,r1,#25
000068  f4034300          AND      r3,r3,#0x8000         ;995
00006c  d502              BPL      |L19.116|
00006e  b10b              CBZ      r3,|L19.116|
;;;998        {
;;;999            u32Flag |= SPI_SPIEN_STS_MASK;
000070  f0400040          ORR      r0,r0,#0x40
                  |L19.116|
;;;1000       }
;;;1001   
;;;1002       u32TmpValue = spi->STATUS & SPI_STATUS_SSLINE_Msk;
000074  6952              LDR      r2,[r2,#0x14]
;;;1003       /* Check SPIx_SS line status */
;;;1004       if((u32Mask & SPI_SSLINE_STS_MASK) && (u32TmpValue))
000076  0609              LSLS     r1,r1,#24
000078  f0020210          AND      r2,r2,#0x10           ;1002
00007c  d503              BPL      |L19.134|
00007e  2a00              CMP      r2,#0
000080  d001              BEQ      |L19.134|
;;;1005       {
;;;1006           u32Flag |= SPI_SSLINE_STS_MASK;
000082  f0400080          ORR      r0,r0,#0x80
                  |L19.134|
;;;1007       }
;;;1008   
;;;1009       return u32Flag;
;;;1010   }
000086  bd10              POP      {r4,pc}
;;;1011   
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;43       */
;;;44     uint32_t SPI_Open(SPI_T *spi,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;45                       uint32_t u32MasterSlave,
;;;46                       uint32_t u32SPIMode,
;;;47                       uint32_t u32DataWidth,
;;;48                       uint32_t u32BusClock)
;;;49     {
000004  4604              MOV      r4,r0
;;;50         uint32_t u32ClkSrc = 0U, u32Div, u32HCLKFreq, u32RetValue=0U;
;;;51     
;;;52         /* Disable I2S mode */
;;;53         spi->I2SCTL &= ~SPI_I2SCTL_I2SEN_Msk;
000006  9d08              LDR      r5,[sp,#0x20]
000008  6e00              LDR      r0,[r0,#0x60]
00000a  461f              MOV      r7,r3                 ;49
00000c  4692              MOV      r10,r2                ;49
00000e  4689              MOV      r9,r1                 ;49
000010  f0200001          BIC      r0,r0,#1
000014  6620              STR      r0,[r4,#0x60]
;;;54     
;;;55         if(u32DataWidth == 32U)
000016  2b20              CMP      r3,#0x20
000018  d100              BNE      |L20.28|
;;;56         {
;;;57             u32DataWidth = 0U;
00001a  2700              MOVS     r7,#0
                  |L20.28|
;;;58         }
;;;59     
;;;60         /* Get system clock frequency */
;;;61         u32HCLKFreq = CLK_GetHCLKFreq();
00001c  f7fffffe          BL       CLK_GetHCLKFreq
;;;62     
;;;63         if(u32MasterSlave == SPI_MASTER)
;;;64         {
;;;65             /* Default setting: slave selection signal is active low; disable automatic slave selection function. */
;;;66             spi->SSCTL = SPI_SS_ACTIVE_LOW;
;;;67     
;;;68             /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;69             spi->CTL = u32MasterSlave | (u32DataWidth << SPI_CTL_DWIDTH_Pos) | (u32SPIMode) | SPI_CTL_SPIEN_Msk;
;;;70     
;;;71             if(u32BusClock >= u32HCLKFreq)
;;;72             {
;;;73                 /* Select PCLK as the clock source of SPI */
;;;74                 if(spi == SPI0)
;;;75                 {
;;;76                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;77                 }
;;;78                 else if(spi == SPI1)
000020  4a71              LDR      r2,|L20.488|
000022  f8dfc1c0          LDR      r12,|L20.484|
;;;79                 {
;;;80                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;81                 }
;;;82                 else if(spi == SPI2)
000026  4b71              LDR      r3,|L20.492|
000028  0451              LSLS     r1,r2,#17             ;76
00002a  4606              MOV      r6,r0                 ;61
00002c  f04f0800          MOV      r8,#0                 ;61
000030  f1b90f00          CMP      r9,#0                 ;63
000034  d013              BEQ      |L20.94|
;;;83                 {
;;;84                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;85                 }
;;;86                 else
;;;87                 {
;;;88                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
;;;89                 }
;;;90             }
;;;91     
;;;92             /* Check clock source of SPI */
;;;93             if(spi == SPI0)
;;;94             {
;;;95                 if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;96                 {
;;;97                     u32ClkSrc = __HXT; /* Clock source is HXT */
;;;98                 }
;;;99                 else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
;;;100                {
;;;101                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;102                }
;;;103                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
;;;104                {
;;;105                    /* Clock source is PCLK1 */
;;;106                    u32ClkSrc = CLK_GetPCLK1Freq();
;;;107                }
;;;108                else
;;;109                {
;;;110                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;111                }
;;;112            }
;;;113            else if(spi == SPI1)
;;;114            {
;;;115                if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
;;;116                {
;;;117                    u32ClkSrc = __HXT; /* Clock source is HXT */
;;;118                }
;;;119                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
;;;120                {
;;;121                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;122                }
;;;123                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
;;;124                {
;;;125                    /* Clock source is PCLK0 */
;;;126                    u32ClkSrc = CLK_GetPCLK0Freq();
;;;127                }
;;;128                else
;;;129                {
;;;130                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;131                }
;;;132            }
;;;133            else if(spi == SPI2)
;;;134            {
;;;135                if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;136                {
;;;137                    u32ClkSrc = __HXT; /* Clock source is HXT */
;;;138                }
;;;139                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;140                {
;;;141                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;142                }
;;;143                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;144                {
;;;145                    u32ClkSrc = CLK_GetPCLK1Freq();
;;;146                }
;;;147                else
;;;148                {
;;;149                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;150                }
;;;151            }
;;;152            else
;;;153            {
;;;154                if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
;;;155                {
;;;156                    u32ClkSrc = __HXT; /* Clock source is HXT */
;;;157                }
;;;158                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
;;;159                {
;;;160                    u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;161                }
;;;162                else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
;;;163                {
;;;164                    /* Clock source is PCLK0 */
;;;165                    u32ClkSrc = CLK_GetPCLK0Freq();
;;;166                }
;;;167                else
;;;168                {
;;;169                    u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;170                }
;;;171            }
;;;172    
;;;173            if(u32BusClock >= u32HCLKFreq)
;;;174            {
;;;175                /* Set DIVIDER = 0 */
;;;176                spi->CLKDIV = 0U;
;;;177                /* Return master peripheral clock rate */
;;;178                u32RetValue = u32ClkSrc;
;;;179            }
;;;180            else if(u32BusClock >= u32ClkSrc)
;;;181            {
;;;182                /* Set DIVIDER = 0 */
;;;183                spi->CLKDIV = 0U;
;;;184                /* Return master peripheral clock rate */
;;;185                u32RetValue = u32ClkSrc;
;;;186            }
;;;187            else if(u32BusClock == 0U)
;;;188            {
;;;189                /* Set DIVIDER to the maximum value 0xFF. f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;190                spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;191                /* Return master peripheral clock rate */
;;;192                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;193            }
;;;194            else
;;;195            {
;;;196                u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;197                if(u32Div > 0xFFU)
;;;198                {
;;;199                    u32Div = 0xFFU;
;;;200                    spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;201                    /* Return master peripheral clock rate */
;;;202                    u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;203                }
;;;204                else
;;;205                {
;;;206                    spi->CLKDIV = (spi->CLKDIV & (~SPI_CLKDIV_DIVIDER_Msk)) | (u32Div << SPI_CLKDIV_DIVIDER_Pos);
;;;207                    /* Return master peripheral clock rate */
;;;208                    u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;209                }
;;;210            }
;;;211        }
;;;212        else     /* For slave mode, force the SPI peripheral clock rate to equal APB clock rate. */
;;;213        {
;;;214            /* Default setting: slave selection signal is low level active. */
;;;215            spi->SSCTL = SPI_SS_ACTIVE_LOW;
000036  f8c48008          STR      r8,[r4,#8]
;;;216    
;;;217            /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;218            spi->CTL = u32MasterSlave | (u32DataWidth << SPI_CTL_DWIDTH_Pos) | (u32SPIMode) | SPI_CTL_SPIEN_Msk;
00003a  ea492007          ORR      r0,r9,r7,LSL #8
00003e  ea40000a          ORR      r0,r0,r10
000042  f0400001          ORR      r0,r0,#1
000046  6020              STR      r0,[r4,#0]
;;;219    
;;;220            /* Set DIVIDER = 0 */
;;;221            spi->CLKDIV = 0U;
000048  f8c48004          STR      r8,[r4,#4]
;;;222    
;;;223            /* Select PCLK as the clock source of SPI */
;;;224            if(spi == SPI0)
00004c  4564              CMP      r4,r12
00004e  d17d              BNE      |L20.332|
;;;225            {
;;;226                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
000050  f8d10218          LDR      r0,[r1,#0x218]
000054  f0200030          BIC      r0,r0,#0x30
000058  f0400020          ORR      r0,r0,#0x20
;;;227                /* Return slave peripheral clock rate */
;;;228                u32RetValue = CLK_GetPCLK1Freq();
00005c  e0b2              B        |L20.452|
                  |L20.94|
00005e  f8c48008          STR      r8,[r4,#8]            ;66
000062  ea482007          ORR      r0,r8,r7,LSL #8       ;69
000066  ea40000a          ORR      r0,r0,r10             ;69
00006a  f0400001          ORR      r0,r0,#1              ;69
00006e  6020              STR      r0,[r4,#0]            ;69
000070  42b5              CMP      r5,r6                 ;71
000072  d320              BCC      |L20.182|
000074  4564              CMP      r4,r12                ;74
000076  d106              BNE      |L20.134|
000078  f8d10218          LDR      r0,[r1,#0x218]        ;76
00007c  f0200030          BIC      r0,r0,#0x30           ;76
000080  f0400020          ORR      r0,r0,#0x20           ;76
000084  e015              B        |L20.178|
                  |L20.134|
000086  4294              CMP      r4,r2                 ;78
000088  d106              BNE      |L20.152|
00008a  f8d10218          LDR      r0,[r1,#0x218]        ;80
00008e  f02000c0          BIC      r0,r0,#0xc0           ;80
000092  f0400080          ORR      r0,r0,#0x80           ;80
000096  e00c              B        |L20.178|
                  |L20.152|
000098  f8d10218          LDR      r0,[r1,#0x218]        ;88
00009c  429c              CMP      r4,r3                 ;82
00009e  d104              BNE      |L20.170|
0000a0  f4206040          BIC      r0,r0,#0xc00          ;84
0000a4  f4406000          ORR      r0,r0,#0x800          ;84
0000a8  e003              B        |L20.178|
                  |L20.170|
0000aa  f4205040          BIC      r0,r0,#0x3000         ;88
0000ae  f4405000          ORR      r0,r0,#0x2000         ;88
                  |L20.178|
0000b2  f8c10218          STR      r0,[r1,#0x218]        ;84
                  |L20.182|
0000b6  484e              LDR      r0,|L20.496|
0000b8  4564              CMP      r4,r12                ;93
0000ba  d10f              BNE      |L20.220|
0000bc  f8d12218          LDR      r2,[r1,#0x218]        ;95
0000c0  f0120f30          TST      r2,#0x30              ;95
0000c4  d048              BEQ      |L20.344|
0000c6  f8d12218          LDR      r2,[r1,#0x218]        ;99
0000ca  f3c21201          UBFX     r2,r2,#4,#2           ;99
0000ce  2a01              CMP      r2,#1                 ;99
0000d0  d03d              BEQ      |L20.334|
0000d2  f8d11218          LDR      r1,[r1,#0x218]        ;103
0000d6  f3c11101          UBFX     r1,r1,#4,#2           ;103
0000da  e022              B        |L20.290|
                  |L20.220|
0000dc  4294              CMP      r4,r2                 ;113
0000de  d10f              BNE      |L20.256|
0000e0  f8d12218          LDR      r2,[r1,#0x218]        ;115
0000e4  f0120fc0          TST      r2,#0xc0              ;115
0000e8  d036              BEQ      |L20.344|
0000ea  f8d12218          LDR      r2,[r1,#0x218]        ;119
0000ee  f3c21281          UBFX     r2,r2,#6,#2           ;119
0000f2  2a01              CMP      r2,#1                 ;119
0000f4  d02b              BEQ      |L20.334|
0000f6  f8d11218          LDR      r1,[r1,#0x218]        ;123
0000fa  f3c11181          UBFX     r1,r1,#6,#2           ;123
0000fe  e022              B        |L20.326|
                  |L20.256|
000100  f8d12218          LDR      r2,[r1,#0x218]        ;154
000104  429c              CMP      r4,r3                 ;133
000106  d111              BNE      |L20.300|
000108  f4126f40          TST      r2,#0xc00             ;135
00010c  d024              BEQ      |L20.344|
00010e  f8d12218          LDR      r2,[r1,#0x218]        ;139
000112  f3c22281          UBFX     r2,r2,#10,#2          ;139
000116  2a01              CMP      r2,#1                 ;139
000118  d019              BEQ      |L20.334|
00011a  f8d11218          LDR      r1,[r1,#0x218]        ;143
00011e  f3c12181          UBFX     r1,r1,#10,#2          ;143
                  |L20.290|
000122  2902              CMP      r1,#2                 ;143
000124  d118              BNE      |L20.344|
000126  f7fffffe          BL       CLK_GetPCLK1Freq
00012a  e015              B        |L20.344|
                  |L20.300|
00012c  f4125f40          TST      r2,#0x3000            ;154
000130  d012              BEQ      |L20.344|
000132  f8d12218          LDR      r2,[r1,#0x218]        ;158
000136  f3c23201          UBFX     r2,r2,#12,#2          ;158
00013a  2a01              CMP      r2,#1                 ;158
00013c  d007              BEQ      |L20.334|
00013e  f8d11218          LDR      r1,[r1,#0x218]        ;162
000142  f3c13101          UBFX     r1,r1,#12,#2          ;162
                  |L20.326|
000146  2902              CMP      r1,#2                 ;162
000148  d004              BEQ      |L20.340|
00014a  e005              B        |L20.344|
                  |L20.332|
00014c  e029              B        |L20.418|
                  |L20.334|
00014e  f7fffffe          BL       CLK_GetPLLClockFreq
000152  e001              B        |L20.344|
                  |L20.340|
000154  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L20.344|
000158  42b5              CMP      r5,r6                 ;173
00015a  d201              BCS      |L20.352|
00015c  4285              CMP      r5,r0                 ;180
00015e  d303              BCC      |L20.360|
                  |L20.352|
000160  f8c48004          STR      r8,[r4,#4]            ;176
                  |L20.356|
;;;229            }
;;;230            else if(spi == SPI1)
;;;231            {
;;;232                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;233                /* Return slave peripheral clock rate */
;;;234                u32RetValue = CLK_GetPCLK0Freq();
;;;235            }
;;;236            else if(spi == SPI2)
;;;237            {
;;;238                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;239                /* Return slave peripheral clock rate */
;;;240                u32RetValue = CLK_GetPCLK1Freq();
;;;241            }
;;;242            else
;;;243            {
;;;244                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
;;;245                /* Return slave peripheral clock rate */
;;;246                u32RetValue = CLK_GetPCLK0Freq();
;;;247            }
;;;248        }
;;;249    
;;;250        return u32RetValue;
;;;251    }
000164  e8bd87f0          POP      {r4-r10,pc}
                  |L20.360|
000168  f24012ff          MOV      r2,#0x1ff             ;190
00016c  b15d              CBZ      r5,|L20.390|
00016e  eb000180          ADD      r1,r0,r0,LSL #2       ;196
000172  0049              LSLS     r1,r1,#1              ;196
000174  fbb1f1f5          UDIV     r1,r1,r5              ;196
000178  230a              MOVS     r3,#0xa               ;196
00017a  1d49              ADDS     r1,r1,#5              ;196
00017c  fbb1f1f3          UDIV     r1,r1,r3              ;196
000180  1e49              SUBS     r1,r1,#1              ;196
000182  29ff              CMP      r1,#0xff              ;197
000184  d904              BLS      |L20.400|
                  |L20.390|
000186  6861              LDR      r1,[r4,#4]            ;190
000188  4311              ORRS     r1,r1,r2              ;190
00018a  6061              STR      r1,[r4,#4]            ;190
00018c  0a00              LSRS     r0,r0,#8              ;192
00018e  e7e9              B        |L20.356|
                  |L20.400|
000190  6862              LDR      r2,[r4,#4]            ;206
000192  f36f0208          BFC      r2,#0,#9              ;206
000196  430a              ORRS     r2,r2,r1              ;206
000198  6062              STR      r2,[r4,#4]            ;206
00019a  1c49              ADDS     r1,r1,#1              ;206
00019c  fbb0f0f1          UDIV     r0,r0,r1              ;208
0001a0  e7e0              B        |L20.356|
                  |L20.418|
0001a2  4294              CMP      r4,r2                 ;230
0001a4  d106              BNE      |L20.436|
0001a6  f8d10218          LDR      r0,[r1,#0x218]        ;232
0001aa  f02000c0          BIC      r0,r0,#0xc0           ;232
0001ae  f0400080          ORR      r0,r0,#0x80           ;232
0001b2  e011              B        |L20.472|
                  |L20.436|
0001b4  f8d10218          LDR      r0,[r1,#0x218]        ;244
0001b8  429c              CMP      r4,r3                 ;236
0001ba  d109              BNE      |L20.464|
0001bc  f4206040          BIC      r0,r0,#0xc00          ;238
0001c0  f4406000          ORR      r0,r0,#0x800          ;238
                  |L20.452|
0001c4  f8c10218          STR      r0,[r1,#0x218]        ;238
0001c8  e8bd47f0          POP      {r4-r10,lr}           ;240
0001cc  f7ffbffe          B.W      CLK_GetPCLK1Freq
                  |L20.464|
0001d0  f4205040          BIC      r0,r0,#0x3000         ;244
0001d4  f4405000          ORR      r0,r0,#0x2000         ;244
                  |L20.472|
0001d8  f8c10218          STR      r0,[r1,#0x218]        ;244
0001dc  e8bd47f0          POP      {r4-r10,lr}           ;246
0001e0  f7ffbffe          B.W      CLK_GetPCLK0Freq
;;;252    
                          ENDP

                  |L20.484|
                          DCD      0x40061000
                  |L20.488|
                          DCD      0x40062000
                  |L20.492|
                          DCD      0x40063000
                  |L20.496|
                          DCD      0x00b71b00

                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;346      */
;;;347    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;348    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;349        uint32_t u32ClkSrc, u32HCLKFreq;
;;;350        uint32_t u32Div, u32RetValue;
;;;351    
;;;352        /* Get system clock frequency */
;;;353        u32HCLKFreq = CLK_GetHCLKFreq();
000008  f7fffffe          BL       CLK_GetHCLKFreq
;;;354    
;;;355        if(u32BusClock >= u32HCLKFreq)
;;;356        {
;;;357            /* Select PCLK as the clock source of SPI */
;;;358            if(spi == SPI0)
;;;359                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;360            else if(spi == SPI1)
00000c  4a4f              LDR      r2,|L21.332|
00000e  4606              MOV      r6,r0                 ;353
000010  4f4d              LDR      r7,|L21.328|
;;;361                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI1SEL_Msk)) | CLK_CLKSEL2_SPI1SEL_PCLK0;
;;;362            else if(spi == SPI2)
000012  4b4f              LDR      r3,|L21.336|
000014  0451              LSLS     r1,r2,#17             ;359
000016  42b5              CMP      r5,r6                 ;355
000018  d320              BCC      |L21.92|
00001a  42bc              CMP      r4,r7                 ;358
00001c  d106              BNE      |L21.44|
00001e  f8d10218          LDR      r0,[r1,#0x218]        ;359
000022  f0200030          BIC      r0,r0,#0x30           ;359
000026  f0400020          ORR      r0,r0,#0x20           ;359
00002a  e015              B        |L21.88|
                  |L21.44|
00002c  4294              CMP      r4,r2                 ;360
00002e  d106              BNE      |L21.62|
000030  f8d10218          LDR      r0,[r1,#0x218]        ;361
000034  f02000c0          BIC      r0,r0,#0xc0           ;361
000038  f0400080          ORR      r0,r0,#0x80           ;361
00003c  e00c              B        |L21.88|
                  |L21.62|
;;;363                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI2SEL_Msk)) | CLK_CLKSEL2_SPI2SEL_PCLK1;
;;;364            else
;;;365                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI3SEL_Msk)) | CLK_CLKSEL2_SPI3SEL_PCLK0;
00003e  f8d10218          LDR      r0,[r1,#0x218]
000042  429c              CMP      r4,r3                 ;362
000044  d104              BNE      |L21.80|
000046  f4206040          BIC      r0,r0,#0xc00          ;363
00004a  f4406000          ORR      r0,r0,#0x800          ;363
00004e  e003              B        |L21.88|
                  |L21.80|
000050  f4205040          BIC      r0,r0,#0x3000
000054  f4405000          ORR      r0,r0,#0x2000
                  |L21.88|
000058  f8c10218          STR      r0,[r1,#0x218]        ;363
                  |L21.92|
;;;366        }
;;;367    
;;;368        /* Check clock source of SPI */
;;;369        if(spi == SPI0)
;;;370        {
;;;371            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;372            {
;;;373                u32ClkSrc = __HXT; /* Clock source is HXT */
00005c  483d              LDR      r0,|L21.340|
00005e  42bc              CMP      r4,r7                 ;369
000060  d10f              BNE      |L21.130|
000062  f8d12218          LDR      r2,[r1,#0x218]        ;371
000066  f0120f30          TST      r2,#0x30              ;371
00006a  d047              BEQ      |L21.252|
;;;374            }
;;;375            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
00006c  f8d12218          LDR      r2,[r1,#0x218]
000070  f3c21201          UBFX     r2,r2,#4,#2
000074  2a01              CMP      r2,#1
000076  d03c              BEQ      |L21.242|
;;;376            {
;;;377                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;378            }
;;;379            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
000078  f8d11218          LDR      r1,[r1,#0x218]
00007c  f3c11101          UBFX     r1,r1,#4,#2
000080  e022              B        |L21.200|
                  |L21.130|
;;;380            {
;;;381                /* Clock source is PCLK1 */
;;;382                u32ClkSrc = CLK_GetPCLK1Freq();
;;;383            }
;;;384            else
;;;385            {
;;;386                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;387            }
;;;388        }
;;;389        else if(spi == SPI1)
000082  4294              CMP      r4,r2
000084  d10f              BNE      |L21.166|
;;;390        {
;;;391            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_HXT)
000086  f8d12218          LDR      r2,[r1,#0x218]
00008a  f0120fc0          TST      r2,#0xc0
00008e  d035              BEQ      |L21.252|
;;;392            {
;;;393                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;394            }
;;;395            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PLL)
000090  f8d12218          LDR      r2,[r1,#0x218]
000094  f3c21281          UBFX     r2,r2,#6,#2
000098  2a01              CMP      r2,#1
00009a  d02a              BEQ      |L21.242|
;;;396            {
;;;397                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;398            }
;;;399            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI1SEL_Msk) == CLK_CLKSEL2_SPI1SEL_PCLK0)
00009c  f8d11218          LDR      r1,[r1,#0x218]
0000a0  f3c11181          UBFX     r1,r1,#6,#2
0000a4  e022              B        |L21.236|
                  |L21.166|
;;;400            {
;;;401                /* Clock source is PCLK0 */
;;;402                u32ClkSrc = CLK_GetPCLK0Freq();
;;;403            }
;;;404            else
;;;405            {
;;;406                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;407            }
;;;408        }
;;;409        else if(spi == SPI2)
;;;410        {
;;;411            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_HXT)
;;;412            {
;;;413                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;414            }
;;;415            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PLL)
;;;416            {
;;;417                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;418            }
;;;419            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI2SEL_Msk) == CLK_CLKSEL2_SPI2SEL_PCLK1)
;;;420            {
;;;421                /* Clock source is PCLK1 */
;;;422                u32ClkSrc = CLK_GetPCLK1Freq();
;;;423            }
;;;424            else
;;;425            {
;;;426                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;427            }
;;;428        }
;;;429        else
;;;430        {
;;;431            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_HXT)
0000a6  f8d12218          LDR      r2,[r1,#0x218]
0000aa  429c              CMP      r4,r3                 ;409
0000ac  d111              BNE      |L21.210|
0000ae  f4126f40          TST      r2,#0xc00             ;411
0000b2  d023              BEQ      |L21.252|
0000b4  f8d12218          LDR      r2,[r1,#0x218]        ;415
0000b8  f3c22281          UBFX     r2,r2,#10,#2          ;415
0000bc  2a01              CMP      r2,#1                 ;415
0000be  d018              BEQ      |L21.242|
0000c0  f8d11218          LDR      r1,[r1,#0x218]        ;419
0000c4  f3c12181          UBFX     r1,r1,#10,#2          ;419
                  |L21.200|
0000c8  2902              CMP      r1,#2                 ;419
0000ca  d117              BNE      |L21.252|
0000cc  f7fffffe          BL       CLK_GetPCLK1Freq
0000d0  e014              B        |L21.252|
                  |L21.210|
0000d2  f4125f40          TST      r2,#0x3000
0000d6  d011              BEQ      |L21.252|
;;;432            {
;;;433                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;434            }
;;;435            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PLL)
0000d8  f8d12218          LDR      r2,[r1,#0x218]
0000dc  f3c23201          UBFX     r2,r2,#12,#2
0000e0  2a01              CMP      r2,#1
0000e2  d006              BEQ      |L21.242|
;;;436            {
;;;437                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;438            }
;;;439            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI3SEL_Msk) == CLK_CLKSEL2_SPI3SEL_PCLK0)
0000e4  f8d11218          LDR      r1,[r1,#0x218]
0000e8  f3c13101          UBFX     r1,r1,#12,#2
                  |L21.236|
0000ec  2902              CMP      r1,#2
0000ee  d003              BEQ      |L21.248|
0000f0  e004              B        |L21.252|
                  |L21.242|
0000f2  f7fffffe          BL       CLK_GetPLLClockFreq
0000f6  e001              B        |L21.252|
                  |L21.248|
;;;440            {
;;;441                /* Clock source is PCLK0 */
;;;442                u32ClkSrc = CLK_GetPCLK0Freq();
0000f8  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L21.252|
0000fc  2100              MOVS     r1,#0
;;;443            }
;;;444            else
;;;445            {
;;;446                u32ClkSrc = __HIRC; /* Clock source is HIRC */
;;;447            }
;;;448        }
;;;449    
;;;450        if(u32BusClock >= u32HCLKFreq)
0000fe  42b5              CMP      r5,r6
000100  d201              BCS      |L21.262|
;;;451        {
;;;452            /* Set DIVIDER = 0 */
;;;453            spi->CLKDIV = 0U;
;;;454            /* Return master peripheral clock rate */
;;;455            u32RetValue = u32ClkSrc;
;;;456        }
;;;457        else if(u32BusClock >= u32ClkSrc)
000102  4285              CMP      r5,r0
000104  d302              BCC      |L21.268|
                  |L21.262|
000106  6061              STR      r1,[r4,#4]            ;453
                  |L21.264|
;;;458        {
;;;459            /* Set DIVIDER = 0 */
;;;460            spi->CLKDIV = 0U;
;;;461            /* Return master peripheral clock rate */
;;;462            u32RetValue = u32ClkSrc;
;;;463        }
;;;464        else if(u32BusClock == 0U)
;;;465        {
;;;466            /* Set DIVIDER to the maximum value 0xFF. f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;467            spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;468            /* Return master peripheral clock rate */
;;;469            u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;470        }
;;;471        else
;;;472        {
;;;473            u32Div = (((u32ClkSrc * 10U) / u32BusClock + 5U) / 10U) - 1U; /* Round to the nearest integer */
;;;474            if(u32Div > 0x1FFU)
;;;475            {
;;;476                u32Div = 0x1FFU;
;;;477                spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;478                /* Return master peripheral clock rate */
;;;479                u32RetValue = (u32ClkSrc / (0xFFU + 1U));
;;;480            }
;;;481            else
;;;482            {
;;;483                spi->CLKDIV = (spi->CLKDIV & (~SPI_CLKDIV_DIVIDER_Msk)) | (u32Div << SPI_CLKDIV_DIVIDER_Pos);
;;;484                /* Return master peripheral clock rate */
;;;485                u32RetValue = (u32ClkSrc / (u32Div + 1U));
;;;486            }
;;;487        }
;;;488    
;;;489        return u32RetValue;
;;;490    }
000108  e8bd81f0          POP      {r4-r8,pc}
                  |L21.268|
00010c  f24012ff          MOV      r2,#0x1ff             ;467
000110  b165              CBZ      r5,|L21.300|
000112  eb000180          ADD      r1,r0,r0,LSL #2       ;473
000116  0049              LSLS     r1,r1,#1              ;473
000118  fbb1f1f5          UDIV     r1,r1,r5              ;473
00011c  230a              MOVS     r3,#0xa               ;473
00011e  1d49              ADDS     r1,r1,#5              ;473
000120  fbb1f1f3          UDIV     r1,r1,r3              ;473
000124  1e49              SUBS     r1,r1,#1              ;473
000126  f5b17f00          CMP      r1,#0x200             ;474
00012a  d304              BCC      |L21.310|
                  |L21.300|
00012c  6861              LDR      r1,[r4,#4]            ;467
00012e  4311              ORRS     r1,r1,r2              ;467
000130  6061              STR      r1,[r4,#4]            ;467
000132  0a00              LSRS     r0,r0,#8              ;469
000134  e7e8              B        |L21.264|
                  |L21.310|
000136  6862              LDR      r2,[r4,#4]            ;483
000138  f36f0208          BFC      r2,#0,#9              ;483
00013c  430a              ORRS     r2,r2,r1              ;483
00013e  6062              STR      r2,[r4,#4]            ;483
000140  1c49              ADDS     r1,r1,#1              ;483
000142  fbb0f0f1          UDIV     r0,r0,r1              ;485
000146  e7df              B        |L21.264|
;;;491    
                          ENDP

                  |L21.328|
                          DCD      0x40061000
                  |L21.332|
                          DCD      0x40062000
                  |L21.336|
                          DCD      0x40063000
                  |L21.340|
                          DCD      0x00b71b00

                          AREA ||i.SPI_SetFIFO||, CODE, READONLY, ALIGN=1

                  SPI_SetFIFO PROC
;;;499      */
;;;500    void SPI_SetFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  6903              LDR      r3,[r0,#0x10]
;;;501    {
;;;502        spi->FIFOCTL = (spi->FIFOCTL & ~(SPI_FIFOCTL_TXTH_Msk | SPI_FIFOCTL_RXTH_Msk)) |
000002  f02343ee          BIC      r3,r3,#0x77000000
000006  ea437101          ORR      r1,r3,r1,LSL #28
00000a  ea416102          ORR      r1,r1,r2,LSL #24
00000e  6101              STR      r1,[r0,#0x10]
;;;503                       (u32TxThreshold << SPI_FIFOCTL_TXTH_Pos) |
;;;504                       (u32RxThreshold << SPI_FIFOCTL_RXTH_Pos);
;;;505    }
000010  4770              BX       lr
;;;506    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 402
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____RRX|
#line 587
|__asm___5_spi_c_SPI_Open____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
