; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -DENABLE_SPI_SLAVE --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;267    
;;;268    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;269    {
;;;270    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;271    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;272    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;273    	
;;;274    }
;;;275    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;211    
;;;212    void SPI_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;213    {
;;;214    	SYS_ResetModule(SPI0_RST);
000002  480d              LDR      r0,|L2.56|
000004  f7fffffe          BL       SYS_ResetModule
;;;215        SPI_Open(BridgeSpiPortNum, SPI_SLAVE, SPI_MODE_0, 8, (uint32_t)NULL);
000008  2000              MOVS     r0,#0
00000a  4c0c              LDR      r4,|L2.60|
00000c  2204              MOVS     r2,#4
00000e  9000              STR      r0,[sp,#0]
000010  2308              MOVS     r3,#8
000012  0411              LSLS     r1,r2,#16
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_Open
;;;216    	
;;;217    	SPI_ClearRxFIFO(BridgeSpiPortNum);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_ClearRxFIFO
;;;218    	SPI_ClearTxFIFO(BridgeSpiPortNum);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPI_ClearTxFIFO
;;;219    	SPI_SetFIFO(BridgeSpiPortNum,2,2);
000026  2202              MOVS     r2,#2
000028  4611              MOV      r1,r2
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_SetFIFO
;;;220    
;;;221        SPI_WRITE_TX(BridgeSpiPortNum, 0xFF);    /* Dummy Write to prevent TX under run */
000030  21ff              MOVS     r1,#0xff
000032  6221              STR      r1,[r4,#0x20]
;;;222    
;;;223    }
000034  bd38              POP      {r3-r5,pc}
;;;224    
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x0400000d
                  |L2.60|
                          DCD      0x40061000

                          AREA ||i.SPI_Slave_Process||, CODE, READONLY, ALIGN=2

                  SPI_Slave_Process PROC
;;;82     
;;;83     void SPI_Slave_Process(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;84     {
;;;85     	#if 1	// send data at next clock in same packet
;;;86     	volatile uint8_t flag_time_out = 0;
000004  2700              MOVS     r7,#0
000006  f88d7000          STRB     r7,[sp,#0]
;;;87     	volatile uint32_t counter_time_out = 0;
;;;88     //	static uint8_t u8Data = 0;
;;;89     	
;;;90     	do
;;;91     	{
;;;92     		//printf("wait for SPI_SSACT_INT_MASK\r\n");
;;;93     	}while(SPI_GetIntFlag(BridgeSpiPortNum ,SPI_SSACT_INT_MASK ) == 0);
00000a  4c27              LDR      r4,|L3.168|
00000c  9701              STR      r7,[sp,#4]
                  |L3.14|
00000e  2102              MOVS     r1,#2
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SPI_GetIntFlag
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L3.14|
;;;94     	SPI_ClearIntFlag(BridgeSpiPortNum , SPI_SSACT_INT_MASK);
00001a  2102              MOVS     r1,#2
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_ClearIntFlag
;;;95     
;;;96     	SPI_ClearTxFIFO(BridgeSpiPortNum);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       SPI_ClearTxFIFO
;;;97     	SPI_ClearRxFIFO(BridgeSpiPortNum);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_ClearRxFIFO
;;;98     
;;;99     	TxDataCount = 0;
00002e  4e1f              LDR      r6,|L3.172|
;;;100    	RxDataCount = 0;
;;;101    
;;;102    	while(SPI_GetIntFlag(BridgeSpiPortNum,SPI_SSINACT_INT_MASK) == 0)
;;;103    	{
;;;104    		flag_time_out = 0 ;
;;;105    		counter_time_out = 0xFFFF;
;;;106    		do
;;;107    		{
;;;108    			if (SPI_GET_RX_FIFO_EMPTY_FLAG(BridgeSpiPortNum) == 0)
;;;109    			{
;;;110    				break;
;;;111    			}
;;;112    
;;;113    			if (counter_time_out-- == 0)
;;;114    			{
;;;115    				flag_time_out = 1;
;;;116    				break;
;;;117    			}
;;;118    
;;;119    		}while(1);
;;;120    
;;;121    		if (flag_time_out)
;;;122    		{
;;;123    			break;
;;;124    		}
;;;125    
;;;126    //		u8Data = SPI_READ_RX(BridgeSpiPortNum);		
;;;127    		buffer[RxDataCount++] = SPI_READ_RX(BridgeSpiPortNum);
000030  4d1f              LDR      r5,|L3.176|
000032  6037              STR      r7,[r6,#0]            ;100  ; TxDataCount
000034  6077              STR      r7,[r6,#4]            ;102  ; RxDataCount
000036  e01e              B        |L3.118|
                  |L3.56|
000038  f88d7000          STRB     r7,[sp,#0]            ;104
00003c  f64f70ff          MOV      r0,#0xffff            ;105
000040  9001              STR      r0,[sp,#4]            ;105
                  |L3.66|
000042  6960              LDR      r0,[r4,#0x14]         ;108
000044  05c0              LSLS     r0,r0,#23             ;108
000046  d506              BPL      |L3.86|
000048  9801              LDR      r0,[sp,#4]            ;113
00004a  1e41              SUBS     r1,r0,#1              ;113
00004c  9101              STR      r1,[sp,#4]            ;113
00004e  d2f8              BCS      |L3.66|
000050  2001              MOVS     r0,#1                 ;115
000052  f88d0000          STRB     r0,[sp,#0]            ;115
                  |L3.86|
000056  f89d0000          LDRB     r0,[sp,#0]            ;121
00005a  b990              CBNZ     r0,|L3.130|
00005c  6b21              LDR      r1,[r4,#0x30]
00005e  6870              LDR      r0,[r6,#4]  ; RxDataCount
000060  5429              STRB     r1,[r5,r0]
000062  1c40              ADDS     r0,r0,#1
;;;128    		
;;;129    	    if (SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0)
000064  6070              STR      r0,[r6,#4]  ; RxDataCount
000066  6960              LDR      r0,[r4,#0x14]
000068  0380              LSLS     r0,r0,#14
00006a  d404              BMI      |L3.118|
;;;130    	    {
;;;131    //	        SPI_WRITE_TX(BridgeSpiPortNum, u8Data);	
;;;132    			SPI_WRITE_TX(BridgeSpiPortNum, buffer[TxDataCount++]);
00006c  6830              LDR      r0,[r6,#0]  ; TxDataCount
00006e  5c29              LDRB     r1,[r5,r0]
000070  6221              STR      r1,[r4,#0x20]
000072  1c40              ADDS     r0,r0,#1
000074  6030              STR      r0,[r6,#0]  ; TxDataCount
                  |L3.118|
000076  2104              MOVS     r1,#4                 ;102
000078  4620              MOV      r0,r4                 ;102
00007a  f7fffffe          BL       SPI_GetIntFlag
00007e  2800              CMP      r0,#0                 ;102
000080  d0da              BEQ      |L3.56|
                  |L3.130|
;;;133    	    }		
;;;134    	};
;;;135    
;;;136    	if (SPI_GetIntFlag(BridgeSpiPortNum,SPI_SSINACT_INT_MASK))
000082  2104              MOVS     r1,#4
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       SPI_GetIntFlag
00008a  2800              CMP      r0,#0
00008c  d00a              BEQ      |L3.164|
;;;137    	{
;;;138    		SPI_ClearIntFlag(BridgeSpiPortNum , SPI_SSINACT_INT_MASK);
00008e  2104              MOVS     r1,#4
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       SPI_ClearIntFlag
;;;139    		TxDataCount = 0;
;;;140    		RxDataCount = 0;
000096  6037              STR      r7,[r6,#0]  ; TxDataCount
;;;141    		
;;;142            if (SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0)
000098  6077              STR      r7,[r6,#4]  ; RxDataCount
00009a  6960              LDR      r0,[r4,#0x14]
00009c  0380              LSLS     r0,r0,#14
00009e  d401              BMI      |L3.164|
;;;143            {
;;;144                SPI_WRITE_TX(BridgeSpiPortNum, 0xFF);    /* Write to TX FIFO */
0000a0  20ff              MOVS     r0,#0xff
0000a2  6220              STR      r0,[r4,#0x20]
                  |L3.164|
;;;145            }
;;;146    	}
;;;147    		
;;;148    	#else
;;;149    
;;;150    
;;;151    	#if 1	//below 2 method , same result , send data packet , at next transmission
;;;152    	
;;;153    	do
;;;154    	{
;;;155    		//printf("wait for SPI_GET_SSACTIF_FLAG\r\n");
;;;156    	}while(SPI_GET_SSACTIF_FLAG(BridgeSpiPortNum) == 0);
;;;157    	SPI_SET_SSACTIF_FLAG(BridgeSpiPortNum);
;;;158    
;;;159    	SPI_ClearTxFIFO(BridgeSpiPortNum);
;;;160    	SPI_ClearRxFIFO(BridgeSpiPortNum);
;;;161    
;;;162    	TxDataCount = 0;
;;;163    	RxDataCount = 0;
;;;164    
;;;165    	while(SPI_GET_SSINAIF_FLAG(BridgeSpiPortNum) == 0)
;;;166    	{	
;;;167    		if (SPI_GET_RX_FIFO_EMPTY_FLAG(BridgeSpiPortNum) == 0)
;;;168    		{
;;;169    			buffer[RxDataCount++] = SPI_READ_RX(BridgeSpiPortNum);
;;;170    		}
;;;171    		
;;;172    	    if ((SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0) && (TxDataCount < MASTER_DATA_NUM))
;;;173    	    {
;;;174    	        SPI_WRITE_TX(BridgeSpiPortNum, buffer[TxDataCount++]);
;;;175    	    }				
;;;176    	};
;;;177    
;;;178    	if (SPI_GET_SSINAIF_FLAG(BridgeSpiPortNum))
;;;179    	{
;;;180    		SPI_SET_SSINAIF_FLAG(BridgeSpiPortNum);
;;;181    		TxDataCount = 0;
;;;182    		RxDataCount = 0;
;;;183    		
;;;184            if (SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0)
;;;185            {
;;;186                SPI_WRITE_TX(BridgeSpiPortNum, 0xFF);    /* Write to TX FIFO */
;;;187            }
;;;188    	}
;;;189    
;;;190    	#else
;;;191    	SPI_ClearTxFIFO(BridgeSpiPortNum);
;;;192    	SPI_ClearRxFIFO(BridgeSpiPortNum);
;;;193    
;;;194    	TxDataCount = 0;
;;;195    	RxDataCount = 0;
;;;196    
;;;197        while(RxDataCount < MASTER_DATA_NUM)
;;;198        {
;;;199            /* Check TX FULL flag and TX data count */
;;;200            if((SPI_GET_TX_FIFO_FULL_FLAG(BridgeSpiPortNum) == 0) && (TxDataCount < MASTER_DATA_NUM))
;;;201                SPI_WRITE_TX(BridgeSpiPortNum, buffer[TxDataCount++]); /* Write to TX FIFO */
;;;202            /* Check RX EMPTY flag */
;;;203            if(SPI_GET_RX_FIFO_EMPTY_FLAG(BridgeSpiPortNum) == 0)
;;;204                buffer[RxDataCount++] = SPI_READ_RX(BridgeSpiPortNum); /* Read RX FIFO */
;;;205        }	
;;;206    	#endif
;;;207    	
;;;208    	#endif
;;;209    
;;;210    }
0000a4  e8bd81fc          POP      {r2-r8,pc}
;;;211    
                          ENDP

                  |L3.168|
                          DCD      0x40061000
                  |L3.172|
                          DCD      ||area_number.20||
                  |L3.176|
                          DCD      ||.bss||

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;275    
;;;276    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L4.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L4.10|
;;;277    {
;;;278        /*---------------------------------------------------------------------------------------------------------*/
;;;279        /* Init System Clock                                                                                       */
;;;280        /*---------------------------------------------------------------------------------------------------------*/
;;;281        /* Unlock protected registers */
;;;282        SYS_UnlockReg();
;;;283    
;;;284        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;285        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;286    
;;;287        /* Enable External XTAL (4~24 MHz) */
;;;288        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk | CLK_PWRCTL_HIRCEN_Msk);
00002e  2005              MOVS     r0,#5
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;289    
;;;290        /* Waiting for 12MHz clock ready */
;;;291        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk | CLK_STATUS_HIRCSTB_Msk);
000034  2011              MOVS     r0,#0x11
000036  f7fffffe          BL       CLK_WaitClockReady
;;;292    
;;;293        /* Set core clock as PLL_CLOCK from PLL */
;;;294        CLK_SetCoreClock(FREQ_192MHZ);
00003a  481b              LDR      r0,|L4.168|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;295        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;296        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;297    
;;;298        /* Enable UART clock */
;;;299        CLK_EnableModuleClock(UART0_MODULE);
000046  4e19              LDR      r6,|L4.172|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;300    
;;;301        /* Select UART clock source from HXT */
;;;302        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;303    
;;;304        CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
000058  4e15              LDR      r6,|L4.176|
00005a  2200              MOVS     r2,#0
00005c  2120              MOVS     r1,#0x20
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       CLK_SetModuleClock
;;;305        CLK_EnableModuleClock(SPI0_MODULE);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;306    
;;;307    //    CLK_EnableModuleClock(PDMA_MODULE);
;;;308    
;;;309    //	TIMER0_HW_Init();
;;;310    	TIMER1_HW_Init();
00006a  f7fffffe          BL       TIMER1_HW_Init
;;;311    	
;;;312        /* Update System Core Clock */
;;;313        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;314        SystemCoreClockUpdate();
00006e  f7fffffe          BL       SystemCoreClockUpdate
;;;315    
;;;316        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;317        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000072  6be0              LDR      r0,[r4,#0x3c]
000074  f420007f          BIC      r0,r0,#0xff0000
000078  63e0              STR      r0,[r4,#0x3c]
;;;318        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00007a  6be0              LDR      r0,[r4,#0x3c]
00007c  f44000cc          ORR      r0,r0,#0x660000
000080  63e0              STR      r0,[r4,#0x3c]
;;;319    
;;;320        /* Setup SPI0 multi-function pins */
;;;321        SYS->GPA_MFPL |= SYS_GPA_MFPL_PA0MFP_SPI0_MOSI | SYS_GPA_MFPL_PA1MFP_SPI0_MISO | SYS_GPA_MFPL_PA2MFP_SPI0_CLK | SYS_GPA_MFPL_PA3MFP_SPI0_SS;
000082  6b20              LDR      r0,[r4,#0x30]
000084  f2444144          MOV      r1,#0x4444
000088  4308              ORRS     r0,r0,r1
00008a  6320              STR      r0,[r4,#0x30]
;;;322    
;;;323        /* Enable SPI0 clock pin (PA2) schmitt trigger */
;;;324        PA->SMTEN |= GPIO_SMTEN_SMTEN2_Msk;
00008c  6a68              LDR      r0,[r5,#0x24]
00008e  f0400004          ORR      r0,r0,#4
000092  6268              STR      r0,[r5,#0x24]
;;;325    
;;;326        /* Enable SPI0 I/O high slew rate */
;;;327        GPIO_SetSlewCtl(PA, 0xF, GPIO_SLEWCTL_HIGH);
000094  2201              MOVS     r2,#1
000096  210f              MOVS     r1,#0xf
000098  4628              MOV      r0,r5
00009a  f7fffffe          BL       GPIO_SetSlewCtl
00009e  2000              MOVS     r0,#0
0000a0  f8c40100          STR      r0,[r4,#0x100]
;;;328    	
;;;329        /* Lock protected registers */
;;;330        SYS_LockReg();
;;;331    }
0000a4  bd70              POP      {r4-r6,pc}
;;;332    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L4.168|
                          DCD      0x0b71b000
                  |L4.172|
                          DCD      0x57803d10
                  |L4.176|
                          DCD      0x6640000d

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;256    
;;;257    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;258    {
;;;259    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L5.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;260    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;261    }
;;;262    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;262    
;;;263    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;264    {
;;;265    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L6.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;266    }
;;;267    
                          ENDP

                  |L6.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;242    
;;;243    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;244    {
;;;245        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L7.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;246        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;247    }
;;;248    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;248    
;;;249    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;250    {
;;;251        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
00001a  4905              LDR      r1,|L8.48|
00001c  2002              MOVS     r0,#2
00001e  f8c10100          STR      r0,[r1,#0x100]
000022  6820              LDR      r0,[r4,#0]
000024  f0404080          ORR      r0,r0,#0x40000000
000028  6020              STR      r0,[r4,#0]
;;;252        TIMER_EnableInt(TIMER1);
;;;253        NVIC_EnableIRQ(TMR1_IRQn);	
;;;254        TIMER_Start(TIMER1);
;;;255    }
00002a  bd10              POP      {r4,pc}
;;;256    
                          ENDP

                  |L8.44|
                          DCD      0x40050100
                  |L8.48|
                          DCD      0xe000e004

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;225    
;;;226    void TMR1_IRQHandler(void)
000000  480d              LDR      r0,|L9.56|
;;;227    {	
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d012              BEQ      |L9.52|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;228    //	static uint32_t log = 0;	
;;;229    	
;;;230        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;231        {
;;;232            TIMER_ClearIntFlag(TIMER1);
;;;233    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4809              LDR      r0,|L9.60|
;;;234    		
;;;235    		if ((get_tick() % 1000) == 0)
000018  f44f717a          MOV      r1,#0x3e8
00001c  6880              LDR      r0,[r0,#8]  ; conter_tick
00001e  fbb0f2f1          UDIV     r2,r0,r1
000022  fb010012          MLS      r0,r1,r2,r0
000026  2800              CMP      r0,#0
000028  d104              BNE      |L9.52|
;;;236    		{
;;;237    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;238    			LED_Y ^= 1;
00002a  4805              LDR      r0,|L9.64|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0810101          EOR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L9.52|
;;;239    		}		
;;;240        }
;;;241    }
000034  bd00              POP      {pc}
;;;242    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      0x40050100
                  |L9.60|
                          DCD      ||area_number.20||
                  |L9.64|
                          DCD      0x400049c4

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;66     
;;;67     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;68     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;69         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;70         
;;;71         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L10.56|
00000a  f7fffffe          BL       __2printf
;;;72         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L10.42|
                  |L10.16|
;;;73         {
;;;74             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L10.76|
000014  f7fffffe          BL       __2printf
;;;75             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L10.38|
;;;76             {
;;;77                 printf("\r\n");
000020  a00c              ADR      r0,|L10.84|
000022  f7fffffe          BL       __2printf
                  |L10.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;72
                  |L10.42|
00002a  42ac              CMP      r4,r5                 ;72
00002c  dbf0              BLT      |L10.16|
;;;78             }            
;;;79         }
;;;80         printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L10.88|
000034  f7ffbffe          B.W      __2printf
;;;81     }
;;;82     
                          ENDP

                  |L10.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L10.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L10.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L10.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;56     
;;;57     uint32_t get_tick(void)
000000  4801              LDR      r0,|L11.8|
;;;58     {
;;;59     	return (conter_tick);
000002  6880              LDR      r0,[r0,#8]  ; conter_tick
;;;60     }
000004  4770              BX       lr
;;;61     
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||area_number.20||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;340    
;;;341    int main()
000000  f7fffffe          BL       SYS_Init
;;;342    {
;;;343    
;;;344        SYS_Init();
;;;345        /* Init UART to 115200-8n1 for print message */
;;;346        UART_Open(UART0, 115200);
000004  f44f31e1          MOV      r1,#0x1c200
000008  4814              LDR      r0,|L12.92|
00000a  f7fffffe          BL       UART_Open
;;;347    
;;;348    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00000e  f7fffffe          BL       CLK_GetCPUFreq
000012  4601              MOV      r1,r0
000014  a012              ADR      r0,|L12.96|
000016  f7fffffe          BL       __2printf
;;;349    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001a  f7fffffe          BL       CLK_GetHXTFreq
00001e  4601              MOV      r1,r0
000020  a016              ADR      r0,|L12.124|
000022  f7fffffe          BL       __2printf
;;;350    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000026  f7fffffe          BL       CLK_GetLXTFreq
00002a  4601              MOV      r1,r0
00002c  a019              ADR      r0,|L12.148|
00002e  f7fffffe          BL       __2printf
;;;351    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000032  f7fffffe          BL       CLK_GetPCLK0Freq
000036  4601              MOV      r1,r0
000038  a01c              ADR      r0,|L12.172|
00003a  f7fffffe          BL       __2printf
;;;352    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00003e  f7fffffe          BL       CLK_GetPCLK1Freq
000042  4601              MOV      r1,r0
000044  a020              ADR      r0,|L12.200|
000046  f7fffffe          BL       __2printf
;;;353    
;;;354    	LED_Init();
00004a  f7fffffe          BL       LED_Init
;;;355    	TIMER1_Init();
00004e  f7fffffe          BL       TIMER1_Init
;;;356    	SPI_Init();
000052  f7fffffe          BL       SPI_Init
                  |L12.86|
;;;357    
;;;358        /* Got no where to go, just loop forever */
;;;359        while(1)
;;;360        {
;;;361    		SPI_Slave_Process();
000056  f7fffffe          BL       SPI_Slave_Process
00005a  e7fc              B        |L12.86|
;;;362    	
;;;363        }
;;;364    }
;;;365    
                          ENDP

                  |L12.92|
                          DCD      0x40070000
                  |L12.96|
000060  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000064  4b5f4765
000068  74435055
00006c  46726571
000070  203a2025
000074  38640d0a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L12.124|
00007c  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000080  47657448
000084  58544672
000088  6571203a
00008c  20253864
000090  0d0a00  
000093  00                DCB      0
                  |L12.148|
000094  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000098  4765744c
00009c  58544672
0000a0  6571203a
0000a4  20253864
0000a8  0d0a00  
0000ab  00                DCB      0
                  |L12.172|
0000ac  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000b0  47657450
0000b4  434c4b30
0000b8  46726571
0000bc  203a2025
0000c0  38640d0a
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L12.200|
0000c8  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000cc  47657450
0000d0  434c4b31
0000d4  46726571
0000d8  203a2025
0000dc  38640d0a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;61     
;;;62     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L13.8|
;;;63     {
;;;64     	conter_tick = t;
000002  6088              STR      r0,[r1,#8]  ; conter_tick
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||area_number.20||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;51     
;;;52     void tick_counter(void)
000000  4802              LDR      r0,|L14.12|
;;;53     {
;;;54     	conter_tick++;
000002  6881              LDR      r1,[r0,#8]  ; conter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; conter_tick
;;;55     }
000008  4770              BX       lr
;;;56     
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      ||area_number.20||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  TestCount
000000  00                DCB      0x00

                          AREA ||area_number.19||, DATA, ALIGN=0

                          EXPORTAS ||area_number.19||, ||.data||
                  RxData
000000  00                DCB      0x00

                          AREA ||area_number.20||, DATA, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.data||
                  TxDataCount
                          DCD      0x00000000
                  RxDataCount
                          DCD      0x00000000
                  conter_tick
                          DCD      0x00000000

                          AREA ||area_number.21||, DATA, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.data||
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_buffer____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_buffer____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_buffer____REVSH|
#line 402
|__asm___6_main_c_buffer____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_buffer____RRX|
#line 587
|__asm___6_main_c_buffer____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
